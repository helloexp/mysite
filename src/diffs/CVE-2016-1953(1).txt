# HG changeset patch
# User Nicolas B. Pierron <nicolas.b.pierron@mozilla.com>

Bug 1199171 part 1 - Assembler::GetCF32Target: Decode instructions as needed. r=

diff --git a/js/src/jit/arm/Assembler-arm.cpp b/js/src/jit/arm/Assembler-arm.cpp
index 0710144..9d361b6 100644
--- a/js/src/jit/arm/Assembler-arm.cpp
+++ b/js/src/jit/arm/Assembler-arm.cpp
@@ -706,30 +706,26 @@ class RelocationIterator
     }
 };
 
 template<class Iter>
 const uint32_t*
 Assembler::GetCF32Target(Iter* iter)
 {
     Instruction* inst1 = iter->cur();
-    Instruction* inst2 = iter->next();
-    Instruction* inst3 = iter->next();
-    Instruction* inst4 = iter->next();
 
     if (inst1->is<InstBranchImm>()) {
         // See if we have a simple case, b #offset.
         BOffImm imm;
         InstBranchImm* jumpB = inst1->as<InstBranchImm>();
         jumpB->extractImm(&imm);
         return imm.getDest(inst1)->raw();
     }
 
-    if (inst1->is<InstMovW>() && inst2->is<InstMovT>() &&
-        (inst3->is<InstNOP>() || inst3->is<InstBranchReg>() || inst4->is<InstBranchReg>()))
+    if (inst1->is<InstMovW>())
     {
         // See if we have the complex case:
         //  movw r_temp, #imm1
         //  movt r_temp, #imm2
         //  bx r_temp
         // OR
         //  movw r_temp, #imm1
         //  movt r_temp, #imm2
@@ -741,29 +737,37 @@ Assembler::GetCF32Target(Iter* iter)
         Register temp;
 
         // Extract both the temp register and the bottom immediate.
         InstMovW* bottom = inst1->as<InstMovW>();
         bottom->extractImm(&targ_bot);
         bottom->extractDest(&temp);
 
         // Extract the top part of the immediate.
+        Instruction* inst2 = iter->next();
+        MOZ_ASSERT(inst2->is<InstMovT>());
         InstMovT* top = inst2->as<InstMovT>();
         top->extractImm(&targ_top);
 
         // Make sure they are being loaded into the same register.
         MOZ_ASSERT(top->checkDest(temp));
 
         // Make sure we're branching to the same register.
 #ifdef DEBUG
         // A toggled call sometimes has a NOP instead of a branch for the third
         // instruction. No way to assert that it's valid in that situation.
+        Instruction* inst3 = iter->next();
         if (!inst3->is<InstNOP>()) {
-            InstBranchReg* realBranch = inst3->is<InstBranchReg>() ? inst3->as<InstBranchReg>()
-                                                                   : inst4->as<InstBranchReg>();
+            InstBranchReg* realBranch = nullptr;
+            if (inst3->is<InstBranchReg>()) {
+                realBranch = inst3->as<InstBranchReg>();
+            } else {
+                Instruction* inst4 = iter->next();
+                realBranch = inst4->as<InstBranchReg>();
+            }
             MOZ_ASSERT(realBranch->checkDest(temp));
         }
 #endif
 
         uint32_t* dest = (uint32_t*) (targ_bot.decode() | (targ_top.decode() << 16));
         return dest;
     }
