# HG changeset patch
# User Yury Delendik <ydelendik@mozilla.com>
# Date 1438808144 18000
#      Wed Aug 05 15:55:44 2015 -0500
# Node ID 9a13e02b4cd42bce865362237fbf88b02baab78c
# Parent  2a94276e39798dc8ac197fe81fd61b14b79ffabe
Bug 1179262 - Remove PlayPreview usage from PDF viewer. r=bz

diff --git a/browser/extensions/pdfjs/content/PdfJs.jsm b/browser/extensions/pdfjs/content/PdfJs.jsm
--- a/browser/extensions/pdfjs/content/PdfJs.jsm
+++ b/browser/extensions/pdfjs/content/PdfJs.jsm
@@ -122,21 +122,30 @@ Factory.prototype = {
     this._classID = proto.classID;
 
     var factory = XPCOMUtils._getFactory(targetConstructor);
     this._factory = factory;
 
     var registrar = Cm.QueryInterface(Ci.nsIComponentRegistrar);
     registrar.registerFactory(proto.classID, proto.classDescription,
                               proto.contractID, factory);
+
+    if (proto.classID2) {
+      this._classID2 = proto.classID2;
+      registrar.registerFactory(proto.classID2, proto.classDescription,
+                                proto.contractID2, factory);
+    }
   },
 
   unregister: function unregister() {
     var registrar = Cm.QueryInterface(Ci.nsIComponentRegistrar);
     registrar.unregisterFactory(this._classID, this._factory);
+    if (this._classID2) {
+      registrar.unregisterFactory(this._classID2, this._factory);
+    }
     this._factory = null;
   }
 };
 
 let PdfJs = {
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),
   _registered: false,
   _initialized: false,
@@ -315,36 +324,23 @@ let PdfJs = {
   _ensureRegistered: function _ensureRegistered() {
     if (this._registered) {
       return;
     }
     this._pdfStreamConverterFactory = new Factory();
     Cu.import('resource://pdf.js/PdfStreamConverter.jsm');
     this._pdfStreamConverterFactory.register(PdfStreamConverter);
 
-    this._pdfRedirectorFactory = new Factory();
-    Cu.import('resource://pdf.js/PdfRedirector.jsm');
-    this._pdfRedirectorFactory.register(PdfRedirector);
-
-    Svc.pluginHost.registerPlayPreviewMimeType(PDF_CONTENT_TYPE, true,
-      'data:application/x-moz-playpreview-pdfjs;,');
-
     this._registered = true;
   },
 
   _ensureUnregistered: function _ensureUnregistered() {
     if (!this._registered) {
       return;
     }
     this._pdfStreamConverterFactory.unregister();
     Cu.unload('resource://pdf.js/PdfStreamConverter.jsm');
     delete this._pdfStreamConverterFactory;
 
-    this._pdfRedirectorFactory.unregister();
-    Cu.unload('resource://pdf.js/PdfRedirector.jsm');
-    delete this._pdfRedirectorFactory;
-
-    Svc.pluginHost.unregisterPlayPreviewMimeType(PDF_CONTENT_TYPE);
-
     this._registered = false;
   }
 };
 
diff --git a/browser/extensions/pdfjs/content/PdfStreamConverter.jsm b/browser/extensions/pdfjs/content/PdfStreamConverter.jsm
--- a/browser/extensions/pdfjs/content/PdfStreamConverter.jsm
+++ b/browser/extensions/pdfjs/content/PdfStreamConverter.jsm
@@ -810,16 +810,19 @@ function PdfStreamConverter() {
 
 PdfStreamConverter.prototype = {
 
   // properties required for XPCOM registration:
   classID: Components.ID('{d0c5195d-e798-49d4-b1d3-9324328b2291}'),
   classDescription: 'pdf.js Component',
   contractID: '@mozilla.org/streamconv;1?from=application/pdf&to=*/*',
 
+  classID2: Components.ID('{d0c5195d-e798-49d4-b1d3-9324328b2292}'),
+  contractID2: '@mozilla.org/streamconv;1?from=application/pdf&to=text/html',
+
   QueryInterface: XPCOMUtils.generateQI([
       Ci.nsISupports,
       Ci.nsIStreamConverter,
       Ci.nsIStreamListener,
       Ci.nsIRequestObserver
   ]),
 
   /*
diff --git a/docshell/base/nsWebNavigationInfo.cpp b/docshell/base/nsWebNavigationInfo.cpp
--- a/docshell/base/nsWebNavigationInfo.cpp
+++ b/docshell/base/nsWebNavigationInfo.cpp
@@ -39,16 +39,23 @@ nsWebNavigationInfo::IsTypeSupported(con
   // Note to self: aWebNav could be an nsWebBrowser or an nsDocShell here (or
   // an nsSHistory, but not much we can do with that).  So if we start using
   // it here, we need to be careful to get to the docshell correctly.
 
   // For now just report what the Gecko-Content-Viewers category has
   // to say for itself.
   *aIsTypeSupported = nsIWebNavigationInfo::UNSUPPORTED;
 
+  // We want to claim that the type for PDF documents is unsupported,
+  // so that the internal PDF viewer's stream converted will get used.
+  if (aType.LowerCaseEqualsLiteral("application/pdf") &&
+      nsContentUtils::IsPDFJSEnabled()) {
+    return NS_OK;
+  }
+
   const nsCString& flatType = PromiseFlatCString(aType);
   nsresult rv = IsTypeSupportedInternal(flatType, aIsTypeSupported);
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (*aIsTypeSupported) {
     return rv;
   }
 
diff --git a/dom/base/nsContentUtils.cpp b/dom/base/nsContentUtils.cpp
--- a/dom/base/nsContentUtils.cpp
+++ b/dom/base/nsContentUtils.cpp
@@ -147,16 +147,17 @@
 #include "nsIPluginHost.h"
 #include "nsIRequest.h"
 #include "nsIRunnable.h"
 #include "nsIScriptContext.h"
 #include "nsIScriptError.h"
 #include "nsIScriptGlobalObject.h"
 #include "nsIScriptObjectPrincipal.h"
 #include "nsIScriptSecurityManager.h"
+#include "nsIStreamConverterService.h"
 #include "nsIStringBundle.h"
 #include "nsIURI.h"
 #include "nsIURL.h"
 #include "nsIWebNavigation.h"
 #include "nsIWordBreaker.h"
 #include "nsIXPConnect.h"
 #include "nsJSUtils.h"
 #include "nsLWBrkCIID.h"
@@ -6454,16 +6455,29 @@ nsContentUtils::AllowXULXBLForPrincipal(
   nsCOMPtr<nsIURI> princURI;
   aPrincipal->GetURI(getter_AddRefs(princURI));
   
   return princURI &&
          ((sAllowXULXBL_for_file && SchemeIs(princURI, "file")) ||
           IsSitePermAllow(aPrincipal, "allowXULXBL"));
 }
 
+bool
+nsContentUtils::IsPDFJSEnabled()
+{
+   nsCOMPtr<nsIStreamConverterService> convServ =
+     do_GetService("@mozilla.org/streamConverters;1");
+   nsresult rv = NS_ERROR_FAILURE;
+   bool canConvert = false;
+   if (convServ) {
+     rv = convServ->CanConvert("application/pdf", "text/html", &canConvert);
+   }
+   return NS_SUCCEEDED(rv) && canConvert;
+}
+
 already_AddRefed<nsIDocumentLoaderFactory>
 nsContentUtils::FindInternalContentViewer(const nsACString& aType,
                                           ContentViewerType* aLoaderType)
 {
   if (aLoaderType) {
     *aLoaderType = TYPE_UNSUPPORTED;
   }
 
diff --git a/dom/base/nsContentUtils.h b/dom/base/nsContentUtils.h
--- a/dom/base/nsContentUtils.h
+++ b/dom/base/nsContentUtils.h
@@ -2014,16 +2014,21 @@ public:
    */
   static bool AllowXULXBLForPrincipal(nsIPrincipal* aPrincipal);
 
   /**
    * Perform cleanup that's appropriate for XPCOM shutdown.
    */
   static void XPCOMShutdown();
 
+  /**
+   * Checks if internal PDF viewer is enabled.
+   */
+  static bool IsPDFJSEnabled();
+
   enum ContentViewerType
   {
       TYPE_UNSUPPORTED,
       TYPE_CONTENT,
       TYPE_PLUGIN,
       TYPE_UNKNOWN
   };
 
diff --git a/dom/base/nsObjectLoadingContent.cpp b/dom/base/nsObjectLoadingContent.cpp
--- a/dom/base/nsObjectLoadingContent.cpp
+++ b/dom/base/nsObjectLoadingContent.cpp
@@ -548,16 +548,21 @@ IsPluginEnabledByExtension(nsIURI* uri, 
 {
   nsAutoCString ext;
   GetExtensionFromURI(uri, ext);
 
   if (ext.IsEmpty()) {
     return false;
   }
 
+  // Disables any native PDF plugins, when internal PDF viewer is enabled.
+  if (ext.EqualsIgnoreCase("pdf") && nsContentUtils::IsPDFJSEnabled()) {
+    return false;
+  }
+
   nsRefPtr<nsPluginHost> pluginHost = nsPluginHost::GetInst();
 
   if (!pluginHost) {
     NS_NOTREACHED("No pluginhost");
     return false;
   }
 
   return pluginHost->HavePluginForExtension(ext, mimeType);
@@ -2661,16 +2666,23 @@ nsObjectLoadingContent::GetTypeOfContent
   }
 
   uint32_t caps = GetCapabilities();
 
   if ((caps & eSupportImages) && IsSupportedImage(aMIMEType)) {
     return eType_Image;
   }
 
+  // Faking support of the PDF content as a document for EMBED tags
+  // when internal PDF viewer is enabled.
+  if (aMIMEType.LowerCaseEqualsLiteral("application/pdf") &&
+      nsContentUtils::IsPDFJSEnabled()) {
+    return eType_Document;
+  }
+
   // SVGs load as documents, but are their own capability
   bool isSVG = aMIMEType.LowerCaseEqualsLiteral("image/svg+xml");
   Capabilities supportType = isSVG ? eSupportSVG : eSupportDocuments;
   if ((caps & supportType) && IsSupportedDocument(aMIMEType)) {
     return eType_Document;
   }
 
   nsRefPtr<nsPluginHost> pluginHost = nsPluginHost::GetInst();
