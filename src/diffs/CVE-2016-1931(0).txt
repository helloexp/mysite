# HG changeset patch
# Parent e6ba2d4a2e4930bb359f90312ef6f1ebdc34c0ac
# User Edwin Flores <eflores@mozilla.com>
Bug 1229825 - Make GIF deinterlacer respect the frame rect bounds - r=seth

diff --git a/image/Downscaler.h b/image/Downscaler.h
--- a/image/Downscaler.h
+++ b/image/Downscaler.h
@@ -53,16 +53,17 @@ class Downscaler
 {
 public:
   /// Constructs a new Downscaler which to scale to size @aTargetSize.
   explicit Downscaler(const nsIntSize& aTargetSize);
   ~Downscaler();
 
   const nsIntSize& OriginalSize() const { return mOriginalSize; }
   const nsIntSize& TargetSize() const { return mTargetSize; }
+  const nsIntSize FrameSize() const { return nsIntSize(mFrameRect.width, mFrameRect.height); }
   const gfxSize& Scale() const { return mScale; }
 
   /**
    * Begins a new frame and reinitializes the Downscaler.
    *
    * @param aOriginalSize The original size of this frame, before scaling.
    * @param aFrameRect The region of  the original image which has data.
    *                   Every pixel outside @aFrameRect is considered blank and
diff --git a/image/decoders/nsGIFDecoder2.cpp b/image/decoders/nsGIFDecoder2.cpp
--- a/image/decoders/nsGIFDecoder2.cpp
+++ b/image/decoders/nsGIFDecoder2.cpp
@@ -1172,17 +1172,17 @@ nsGIFDecoder2::WriteInternal(const char*
           }
         }
       }
 
       if (q[8] & 0x40) {
         mGIFStruct.interlaced = true;
         mGIFStruct.ipass = 1;
         if (mDownscaler) {
-          mDeinterlacer.emplace(mDownscaler->OriginalSize());
+          mDeinterlacer.emplace(mDownscaler->FrameSize());
         }
       } else {
         mGIFStruct.interlaced = false;
         mGIFStruct.ipass = 0;
       }
 
       // Only apply the Haeberli display hack on the first frame
       mGIFStruct.progressive_display = (mGIFStruct.images_decoded == 0);
