# HG changeset patch
# User Terrence Cole <terrence@mozilla.com>
# Date 1430850892 25200
#      Tue May 05 11:34:52 2015 -0700
# Node ID 8a9d5fdf7e8f4e7689edd4a0581680c3966b2a05
# Parent  7b38cbca05ed7d677d7330e7c3a22bdf719a67cd
Bug 1159321 - Well-known symbols do not need pre-barriers; NOT_REVIEWED

diff --git a/js/src/gc/Barrier.cpp b/js/src/gc/Barrier.cpp
--- a/js/src/gc/Barrier.cpp
+++ b/js/src/gc/Barrier.cpp
@@ -76,9 +76,15 @@ CurrentThreadIsGCSweeping()
 #endif // DEBUG
 
 bool
 StringIsPermanentAtom(JSString* str)
 {
     return str->isPermanentAtom();
 }
 
+bool
+SymbolIsWellKnown(JS::Symbol* sym)
+{
+    return sym->isWellKnownSymbol();
+}
+
 } // namespace js
diff --git a/js/src/gc/Barrier.h b/js/src/gc/Barrier.h
--- a/js/src/gc/Barrier.h
+++ b/js/src/gc/Barrier.h
@@ -195,16 +195,19 @@ CurrentThreadIsIonCompiling();
 
 bool
 CurrentThreadIsGCSweeping();
 #endif
 
 bool
 StringIsPermanentAtom(JSString* str);
 
+bool
+SymbolIsWellKnown(JS::Symbol* sym);
+
 namespace gc {
 
 template <typename T> struct MapTypeToTraceKind {};
 template <> struct MapTypeToTraceKind<NativeObject>     { static const JSGCTraceKind kind = JSTRACE_OBJECT; };
 template <> struct MapTypeToTraceKind<ArrayObject>      { static const JSGCTraceKind kind = JSTRACE_OBJECT; };
 template <> struct MapTypeToTraceKind<ArgumentsObject>  { static const JSGCTraceKind kind = JSTRACE_OBJECT; };
 template <> struct MapTypeToTraceKind<ArrayBufferObject>{ static const JSGCTraceKind kind = JSTRACE_OBJECT; };
 template <> struct MapTypeToTraceKind<ArrayBufferObjectMaybeShared>{ static const JSGCTraceKind kind = JSTRACE_OBJECT; };
@@ -330,24 +333,28 @@ struct InternalGCMethods<Value>
     }
 
     static bool isMarkable(Value v) { return v.isMarkable(); }
 
     static void preBarrier(Value v) {
         MOZ_ASSERT(!CurrentThreadIsIonCompiling());
         if (v.isString() && StringIsPermanentAtom(v.toString()))
             return;
+        if (v.isSymbol() && SymbolIsWellKnown(v.toSymbol()))
+            return;
         if (v.isMarkable() && shadowRuntimeFromAnyThread(v)->needsIncrementalBarrier())
             preBarrierImpl(ZoneOfValueFromAnyThread(v), v);
     }
 
     static void preBarrier(Zone* zone, Value v) {
         MOZ_ASSERT(!CurrentThreadIsIonCompiling());
         if (v.isString() && StringIsPermanentAtom(v.toString()))
             return;
+        if (v.isSymbol() && SymbolIsWellKnown(v.toSymbol()))
+            return;
         preBarrierImpl(zone, v);
     }
 
   private:
     static void preBarrierImpl(Zone* zone, Value v) {
         JS::shadow::Zone* shadowZone = JS::shadow::Zone::asShadowZone(zone);
         if (shadowZone->needsIncrementalBarrier()) {
             MOZ_ASSERT_IF(v.isMarkable(), shadowRuntimeFromMainThread(v)->needsIncrementalBarrier());
@@ -392,16 +399,18 @@ template <>
 struct InternalGCMethods<jsid>
 {
     static bool isMarkable(jsid id) { return JSID_IS_STRING(id) || JSID_IS_SYMBOL(id); }
 
     static void preBarrier(jsid id) {
         MOZ_ASSERT(!CurrentThreadIsIonCompiling());
         if (JSID_IS_STRING(id) && StringIsPermanentAtom(JSID_TO_STRING(id)))
             return;
+        if (JSID_IS_SYMBOL(id) && SymbolIsWellKnown(JSID_TO_SYMBOL(id)))
+            return;
         if (JSID_IS_GCTHING(id) && shadowRuntimeFromAnyThread(id)->needsIncrementalBarrier())
             preBarrierImpl(ZoneOfIdFromAnyThread(id), id);
     }
 
   private:
     static JSRuntime* runtimeFromAnyThread(jsid id) {
         MOZ_ASSERT(JSID_IS_GCTHING(id));
         return JSID_TO_GCTHING(id).asCell()->runtimeFromAnyThread();
