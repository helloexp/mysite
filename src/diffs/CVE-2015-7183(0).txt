diff --git a/lib/ds/plarena.c b/lib/ds/plarena.c
--- a/lib/ds/plarena.c
+++ b/lib/ds/plarena.c
@@ -88,24 +88,29 @@ PR_IMPLEMENT(void) PL_InitArenaPool(
         align = PL_ARENA_DEFAULT_ALIGN;
 
     if (align < sizeof(pmasks)/sizeof(pmasks[0]))
         pool->mask = pmasks[align];
     else
         pool->mask = PR_BITMASK(PR_CeilingLog2(align));
 
     pool->first.next = NULL;
+    /* Set all three addresses in pool->first to the same dummy value.
+     * These addresses are only compared with each other, but never
+     * dereferenced. */
     pool->first.base = pool->first.avail = pool->first.limit =
         (PRUword)PL_ARENA_ALIGN(pool, &pool->first + 1);
     pool->current = &pool->first;
     /*
      * Compute the net size so that each arena's gross size is |size|.
      * sizeof(PLArena) + pool->mask is the header and alignment slop
      * that PL_ArenaAllocate adds to the net size.
      */
+    // XXX verify pool->mask = PR_BITMASK(PR_CeilingLog2(align)) is small.
+    // This is very likely to be true because of the log2 operation.
     if (size > sizeof(PLArena) + pool->mask)
         pool->arenasize = size - (sizeof(PLArena) + pool->mask);
     else
         pool->arenasize = size;
 #ifdef PL_ARENAMETER
     memset(&pool->stats, 0, sizeof pool->stats);
     pool->stats.name = strdup(name);
     pool->stats.next = arena_stats_list;
@@ -364,16 +369,18 @@ PR_IMPLEMENT(size_t) PL_SizeOfArenaPoolE
     const PLArena *arena = pool->first.next;
     while (arena) {
         size += mallocSizeOf(arena);
         arena = arena->next;
     }
     return size;
 }
 
+// XXX The rest of this file is ignored because it is not compiled unless
+// PL_ARENAMETER is defined.
 #ifdef PL_ARENAMETER
 PR_IMPLEMENT(void) PL_ArenaCountAllocation(PLArenaPool *pool, PRUint32 nb)
 {
     pool->stats.nallocs++;
     pool->stats.nbytes += nb;
     if (nb > pool->stats.maxalloc)
         pool->stats.maxalloc = nb;
     pool->stats.variance += nb * nb;
diff --git a/lib/ds/plarena.h b/lib/ds/plarena.h
--- a/lib/ds/plarena.h
+++ b/lib/ds/plarena.h
@@ -119,16 +119,21 @@ void __asan_unpoison_memory_region(void 
 
 #endif
 
 /*
  * If the including .c file uses only one power-of-2 alignment, it may define
  * PL_ARENA_CONST_ALIGN_MASK to the alignment mask and save a few instructions
  * per ALLOCATE and GROW.
  */
+// XXX Audit the callers of PL_ARENA_ALIGN because the addition of
+// PL_ARENA_CONST_ALIGN_MASK or (pool)->mask may overflow.
+// Callers must verify that the return value of PL_ARENA_ALIGN is >= the second
+// argument. The second argument can be a byte count or an address. The callers
+// that pass a byte count must be audited.
 #ifdef PL_ARENA_CONST_ALIGN_MASK
 #define PL_ARENA_ALIGN(pool, n) (((PRUword)(n) + PL_ARENA_CONST_ALIGN_MASK) \
                                 & ~PL_ARENA_CONST_ALIGN_MASK)
 
 #define PL_INIT_ARENA_POOL(pool, name, size) \
         PL_InitArenaPool(pool, name, size, PL_ARENA_CONST_ALIGN_MASK + 1)
 #else
 #define PL_ARENA_ALIGN(pool, n) (((PRUword)(n) + (pool)->mask) & ~(pool)->mask)
@@ -151,18 +156,20 @@ void __asan_unpoison_memory_region(void 
     PR_END_MACRO
 
 #define PL_ARENA_GROW(p, pool, size, incr) \
     PR_BEGIN_MACRO \
         PLArena *_a = (pool)->current; \
         PRUint32 _incr = PL_ARENA_ALIGN(pool, incr); \
         PRUword _p = _a->avail; \
         PRUword _q = _p + _incr; \
+        /* XXX can this addition overflow? */ \
         if (_p == (PRUword)(p) + PL_ARENA_ALIGN(pool, size) && \
             _q <= _a->limit) { \
+            /* XXX can this addition overflow? */ \
             PL_MAKE_MEM_UNDEFINED((unsigned char *)(p) + size, incr); \
             _a->avail = _q; \
             PL_ArenaCountInplaceGrowth(pool, size, incr); \
         } else { \
             p = PL_ArenaGrow(pool, p, size, incr); \
         } \
         PL_ArenaCountGrowth(pool, size, incr); \
     PR_END_MACRO
