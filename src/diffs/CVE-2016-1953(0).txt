# HG changeset patch
# User Nicolas B. Pierron <nicolas.b.pierron@mozilla.com>
Bug 1199171 part 0 - Add spewInst function for debugging Jit code. r=


diff --git a/js/src/jit/arm/Assembler-arm.cpp b/js/src/jit/arm/Assembler-arm.cpp
index e404884..0710144 100644
--- a/js/src/jit/arm/Assembler-arm.cpp
+++ b/js/src/jit/arm/Assembler-arm.cpp
@@ -1405,16 +1405,27 @@ Assembler::bytesNeeded() const
     return size() +
         jumpRelocationTableBytes() +
         dataRelocationTableBytes() +
         preBarrierTableBytes();
 }
 
 #ifdef JS_DISASM_ARM
 
+void
+Assembler::spewInst(Instruction* i)
+{
+    disasm::NameConverter converter;
+    disasm::Disassembler dasm(converter);
+    disasm::EmbeddedVector<char, disasm::ReasonableBufferSize> buffer;
+    uint8_t* loc = reinterpret_cast<uint8_t*>(const_cast<uint32_t*>(i->raw()));
+    dasm.InstructionDecode(buffer, loc);
+    printf("   %08x  %s\n", reinterpret_cast<uint32_t>(loc), buffer.start());
+}
+
 // Labels are named as they are encountered by adding names to a
 // table, using the Label address as the key.  This is made tricky by
 // the (memory for) Label objects being reused, but reused label
 // objects are recognizable from being marked as not used or not
 // bound.  See spewResolve().
 //
 // In a number of cases there is no information about the target, and
 // we just end up printing "patchable constant load to PC".  This is
diff --git a/js/src/jit/arm/Assembler-arm.h b/js/src/jit/arm/Assembler-arm.h
index 8ef0687..81a2e4b 100644
--- a/js/src/jit/arm/Assembler-arm.h
+++ b/js/src/jit/arm/Assembler-arm.h
@@ -1255,16 +1255,17 @@ class Assembler : public AssemblerShared
                             uint8_t* inst, uint8_t* data, ARMBuffer::PoolEntry* pe = nullptr,
                             bool markAsBranch = false, bool loadToPC = false);
 
     Instruction* editSrc (BufferOffset bo) {
         return m_buffer.getInst(bo);
     }
 
 #ifdef JS_DISASM_ARM
+    static void spewInst(Instruction* i);
     void spew(Instruction* i);
     void spewBranch(Instruction* i, Label* target);
     void spewData(BufferOffset addr, size_t numInstr, bool loadToPC);
     void spewLabel(Label* label);
     void spewRetarget(Label* label, Label* target);
     void spewTarget(Label* l);
 #endif
 
