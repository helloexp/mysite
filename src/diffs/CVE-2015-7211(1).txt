# HG changeset patch
# User Gijs Kruitbosch <gijskruitbosch@gmail.com>
# Date 1446656084 0
#      Wed Nov 04 16:54:44 2015 +0000
# Node ID de5a05864c49f06f0f710e883a5b83fdb54b3b53
# Parent  28e3554983f6af15685da76d7966b1a63e1d2fc0
Bug 1221444, r?bz

diff --git a/netwerk/protocol/data/nsDataHandler.cpp b/netwerk/protocol/data/nsDataHandler.cpp
--- a/netwerk/protocol/data/nsDataHandler.cpp
+++ b/netwerk/protocol/data/nsDataHandler.cpp
@@ -162,21 +162,22 @@ nsDataHandler::ParseURI(nsCString& spec,
     // move past "data:"
     char *buffer = (char *) PL_strcasestr(spec.BeginWriting(), "data:");
     if (!buffer) {
         // malformed uri
         return NS_ERROR_MALFORMED_URI;
     }
     buffer += 5;
 
     // First, find the start of the data
     char *comma = strchr(buffer, ',');
-    if (!comma)
+    char *hash = strchr(buffer, '#');
+    if (!comma || (hash && hash < comma))
         return NS_ERROR_MALFORMED_URI;
 
     *comma = '\0';
 
     // determine if the data is base64 encoded.
     char *base64 = PL_strcasestr(buffer, BASE64_EXTENSION);
     if (base64) {
         char *beyond = base64 + strlen(BASE64_EXTENSION);
         // per the RFC 2397 grammar, "base64" MUST be followed by a comma
         // previously substituted by '\0', but we also allow it in between
@@ -217,21 +218,20 @@ nsDataHandler::ParseURI(nsCString& spec,
 
     *comma = ',';
     if (isBase64)
         *base64 = ';';
 
     contentType.StripWhitespace();
     contentCharset.StripWhitespace();
 
     // Split encoded data from terminal "#ref" (if present)
     char *data = comma + 1;
-    char *hash = strchr(data, '#');
     if (!hash) {
         dataBuffer.Assign(data);
         hashRef.Truncate();
     } else {
         dataBuffer.Assign(data, hash - data);
         hashRef.Assign(hash);
     }
 
     return NS_OK;
 }
