# HG changeset patch
# User Robert Strong <robert.bugzilla@gmail.com>
# Parent  57981d525846af1afc883ce0fef74a7406bb514a

diff --git a/browser/installer/windows/nsis/maintenanceservice_installer.nsi b/browser/installer/windows/nsis/maintenanceservice_installer.nsi
--- a/browser/installer/windows/nsis/maintenanceservice_installer.nsi
+++ b/browser/installer/windows/nsis/maintenanceservice_installer.nsi
@@ -255,16 +255,72 @@ Section "Uninstall"
   Push "$INSTDIR\maintenanceservice.old"
   Call un.RenameDelete
   Push "$INSTDIR\Uninstall.exe"
   Call un.RenameDelete
   Push "$INSTDIR\update\updater.ini"
   Call un.RenameDelete
   Push "$INSTDIR\update\updater.exe"
   Call un.RenameDelete
+  Push "$INSTDIR\logs\maintenanceservice.log"
+  Call un.RenameDelete
+  Push "$INSTDIR\logs\maintenanceservice-1.log"
+  Call un.RenameDelete
+  Push "$INSTDIR\logs\maintenanceservice-2.log"
+  Call un.RenameDelete
+  Push "$INSTDIR\logs\maintenanceservice-3.log"
+  Call un.RenameDelete
+  Push "$INSTDIR\logs\maintenanceservice-4.log"
+  Call un.RenameDelete
+  Push "$INSTDIR\logs\maintenanceservice-5.log"
+  Call un.RenameDelete
+  Push "$INSTDIR\logs\maintenanceservice-6.log"
+  Call un.RenameDelete
+  Push "$INSTDIR\logs\maintenanceservice-7.log"
+  Call un.RenameDelete
+  Push "$INSTDIR\logs\maintenanceservice-8.log"
+  Call un.RenameDelete
+  Push "$INSTDIR\logs\maintenanceservice-9.log"
+  Call un.RenameDelete
+  Push "$INSTDIR\logs\maintenanceservice-10.log"
+  Call un.RenameDelete
+  Push "$INSTDIR\logs\maintenanceservice-install.log"
+  Call un.RenameDelete
+  Push "$INSTDIR\logs\maintenanceservice-uninstall.log"
+  Call un.RenameDelete
+  SetShellVarContext all
+  Push "$APPDATA\Mozilla\logs\maintenanceservice.log"
+  Call un.RenameDelete
+  Push "$APPDATA\Mozilla\logs\maintenanceservice-1.log"
+  Call un.RenameDelete
+  Push "$APPDATA\Mozilla\logs\maintenanceservice-2.log"
+  Call un.RenameDelete
+  Push "$APPDATA\Mozilla\logs\maintenanceservice-3.log"
+  Call un.RenameDelete
+  Push "$APPDATA\Mozilla\logs\maintenanceservice-4.log"
+  Call un.RenameDelete
+  Push "$APPDATA\Mozilla\logs\maintenanceservice-5.log"
+  Call un.RenameDelete
+  Push "$APPDATA\Mozilla\logs\maintenanceservice-6.log"
+  Call un.RenameDelete
+  Push "$APPDATA\Mozilla\logs\maintenanceservice-7.log"
+  Call un.RenameDelete
+  Push "$APPDATA\Mozilla\logs\maintenanceservice-8.log"
+  Call un.RenameDelete
+  Push "$APPDATA\Mozilla\logs\maintenanceservice-9.log"
+  Call un.RenameDelete
+  Push "$APPDATA\Mozilla\logs\maintenanceservice-10.log"
+  Call un.RenameDelete
+  Push "$APPDATA\Mozilla\logs\maintenanceservice-install.log"
+  Call un.RenameDelete
+  Push "$APPDATA\Mozilla\logs\maintenanceservice-uninstall.log"
+  Call un.RenameDelete
+  RMDir /REBOOTOK "$APPDATA\Mozilla\logs"
+  RMDir /REBOOTOK "$APPDATA\Mozilla"
+  RMDir /REBOOTOK "$INSTDIR\logs"
   RMDir /REBOOTOK "$INSTDIR\update"
   RMDir /REBOOTOK "$INSTDIR"
 
   DeleteRegKey HKLM "${MaintUninstallKey}"
 
   ${If} ${RunningX64}
     SetRegView 64
   ${EndIf}
diff --git a/toolkit/components/maintenanceservice/maintenanceservice.cpp b/toolkit/components/maintenanceservice/maintenanceservice.cpp
--- a/toolkit/components/maintenanceservice/maintenanceservice.cpp
+++ b/toolkit/components/maintenanceservice/maintenanceservice.cpp
@@ -120,28 +120,23 @@ wmain(int argc, WCHAR **argv)
  * Obtains the base path where logs should be stored
  *
  * @param  path The out buffer for the backup log path of size MAX_PATH + 1
  * @return TRUE if successful.
  */
 BOOL
 GetLogDirectoryPath(WCHAR *path)
 {
-  HRESULT hr = SHGetFolderPathW(nullptr, CSIDL_COMMON_APPDATA, nullptr, 
-    SHGFP_TYPE_CURRENT, path);
-  if (FAILED(hr)) {
+  if (!GetModuleFileNameW(nullptr, path, MAX_PATH)) {
     return FALSE;
   }
 
-  if (!PathAppendSafe(path, L"Mozilla")) {
+  if (!PathRemoveFileSpecW(path)) {
     return FALSE;
   }
-  // The directory should already be created from the installer, but
-  // just to be safe in case someone deletes.
-  CreateDirectoryW(path, nullptr);
 
   if (!PathAppendSafe(path, L"logs")) {
     return FALSE;
   }
   CreateDirectoryW(path, nullptr);
   return TRUE;
 }
 
diff --git a/toolkit/mozapps/update/common/updatehelper.cpp b/toolkit/mozapps/update/common/updatehelper.cpp
--- a/toolkit/mozapps/update/common/updatehelper.cpp
+++ b/toolkit/mozapps/update/common/updatehelper.cpp
@@ -397,74 +397,59 @@ PathAppendSafe(LPWSTR base, LPCWSTR extr
   if (wcslen(base) + wcslen(extra) >= MAX_PATH) {
     return FALSE;
   }
 
   return PathAppendW(base, extra);
 }
 
 /**
- * Sets update.status to pending so that the next startup will not use
- * the service and instead will attempt an update the with a UAC prompt.
- *
- * @param  updateDirPath The path of the update directory
- * @return TRUE if successful
- */
-BOOL
-WriteStatusPending(LPCWSTR updateDirPath)
-{
-  WCHAR updateStatusFilePath[MAX_PATH + 1] = { L'\0' };
-  wcsncpy(updateStatusFilePath, updateDirPath, MAX_PATH);
-  if (!PathAppendSafe(updateStatusFilePath, L"update.status")) {
-    return FALSE;
-  }
-
-  const char pending[] = "pending";
-  HANDLE statusFile = CreateFileW(updateStatusFilePath, GENERIC_WRITE, 0,
-                                  nullptr, CREATE_ALWAYS, 0, nullptr);
-  if (statusFile == INVALID_HANDLE_VALUE) {
-    return FALSE;
-  }
-
-  DWORD wrote;
-  BOOL ok = WriteFile(statusFile, pending,
-                      sizeof(pending) - 1, &wrote, nullptr);
-  CloseHandle(statusFile);
-  return ok && (wrote == sizeof(pending) - 1);
-}
-
-/**
  * Sets update.status to a specific failure code
  *
  * @param  updateDirPath The path of the update directory
  * @return TRUE if successful
  */
 BOOL
 WriteStatusFailure(LPCWSTR updateDirPath, int errorCode)
 {
+  // The temp file is not removed on failure since there is client code that
+  // will remove it.
+  WCHAR tmpUpdateStatusFilePath[MAX_PATH + 1] = { L'\0' };
+  GetTempFileNameW(updateDirPath, L"svc", 0, tmpUpdateStatusFilePath);
+
+  HANDLE tmpStatusFile = CreateFileW(tmpUpdateStatusFilePath, GENERIC_WRITE, 0,
+                                     nullptr, CREATE_ALWAYS, 0, nullptr);
+  if (tmpStatusFile == INVALID_HANDLE_VALUE) {
+    return FALSE;
+  }
+
+  char failure[32];
+  sprintf(failure, "failed: %d", errorCode);
+  DWORD toWrite = strlen(failure);
+  DWORD wrote;
+  BOOL ok = WriteFile(tmpStatusFile, failure,
+                      toWrite, &wrote, nullptr);
+  CloseHandle(tmpStatusFile);
+
+  if (!ok || wrote != toWrite) {
+    return FALSE;
+  }
+
   WCHAR updateStatusFilePath[MAX_PATH + 1] = { L'\0' };
   wcsncpy(updateStatusFilePath, updateDirPath, MAX_PATH);
   if (!PathAppendSafe(updateStatusFilePath, L"update.status")) {
     return FALSE;
   }
 
-  HANDLE statusFile = CreateFileW(updateStatusFilePath, GENERIC_WRITE, 0,
-                                  nullptr, CREATE_ALWAYS, 0, nullptr);
-  if (statusFile == INVALID_HANDLE_VALUE) {
+  if (MoveFileExW(tmpUpdateStatusFilePath, updateStatusFilePath,
+                  MOVEFILE_REPLACE_EXISTING) == 0) {
     return FALSE;
   }
-  char failure[32];
-  sprintf(failure, "failed: %d", errorCode);
 
-  DWORD toWrite = strlen(failure);
-  DWORD wrote;
-  BOOL ok = WriteFile(statusFile, failure,
-                      toWrite, &wrote, nullptr);
-  CloseHandle(statusFile);
-  return ok && wrote == toWrite;
+  return TRUE;
 }
 
 #endif
 
 /**
  * Waits for a service to enter a stopped state.
  * This function does not stop the service, it just blocks until the service
  * is stopped.
diff --git a/toolkit/mozapps/update/common/updatehelper.h b/toolkit/mozapps/update/common/updatehelper.h
--- a/toolkit/mozapps/update/common/updatehelper.h
+++ b/toolkit/mozapps/update/common/updatehelper.h
@@ -5,17 +5,16 @@
 BOOL LaunchWinPostProcess(const WCHAR *installationDir,
                           const WCHAR *updateInfoDir,
                           bool forceSync,
                           HANDLE userToken);
 BOOL StartServiceUpdate(LPCWSTR installDir);
 BOOL GetUpdateDirectoryPath(LPWSTR path);
 DWORD LaunchServiceSoftwareUpdateCommand(int argc, LPCWSTR *argv);
 BOOL WriteStatusFailure(LPCWSTR updateDirPath, int errorCode);
-BOOL WriteStatusPending(LPCWSTR updateDirPath);
 DWORD WaitForServiceStop(LPCWSTR serviceName, DWORD maxWaitSeconds);
 DWORD WaitForProcessExit(LPCWSTR filename, DWORD maxSeconds);
 BOOL DoesFallbackKeyExist();
 BOOL IsLocalFile(LPCWSTR file, BOOL &isLocal);
 DWORD StartServiceCommand(int argc, LPCWSTR* argv);
 BOOL IsUnpromptedElevation(BOOL &isUnpromptedElevation);
 
 #define SVC_NAME L"MozillaMaintenance"
diff --git a/toolkit/mozapps/update/common/updatelogging.cpp b/toolkit/mozapps/update/common/updatelogging.cpp
--- a/toolkit/mozapps/update/common/updatelogging.cpp
+++ b/toolkit/mozapps/update/common/updatelogging.cpp
@@ -21,36 +21,61 @@ UpdateLog::UpdateLog() : logFP(nullptr)
 void UpdateLog::Init(NS_tchar* sourcePath,
                      const NS_tchar* fileName,
                      const NS_tchar* alternateFileName,
                      bool append)
 {
   if (logFP)
     return;
 
-  this->sourcePath = sourcePath;
-  NS_tchar logFile[MAXPATHLEN];
-  NS_tsnprintf(logFile, sizeof(logFile)/sizeof(logFile[0]),
-    NS_T("%s/%s"), sourcePath, fileName);
+#ifdef XP_WIN
+  GetTempFileNameW(sourcePath, L"log", 0, mTmpFilePath);
+  if (append) {
+    NS_tsnprintf(mDstFilePath, sizeof(mDstFilePath)/sizeof(mDstFilePath[0]),
+      NS_T("%s/%s"), sourcePath, alternateFileName);
+    MoveFileExW(mDstFilePath, mTmpFilePath, MOVEFILE_REPLACE_EXISTING);
+  } else {
+    NS_tsnprintf(mDstFilePath, sizeof(mDstFilePath)/sizeof(mDstFilePath[0]),
+                 NS_T("%s/%s"), sourcePath, fileName);
+  }
 
-  if (alternateFileName && NS_taccess(logFile, F_OK)) {
-    NS_tsnprintf(logFile, sizeof(logFile)/sizeof(logFile[0]),
+  logFP = NS_tfopen(mTmpFilePath, append ? NS_T("a") : NS_T("w"));
+  // Delete this file now so it is possible to tell from the unelevated
+  // updater process if the elevated updater process has written the log.
+  DeleteFileW(mDstFilePath);
+#else
+  NS_tsnprintf(mDstFilePath, sizeof(mDstFilePath)/sizeof(mDstFilePath[0]),
+               NS_T("%s/%s"), sourcePath, fileName);
+
+  if (alternateFileName && NS_taccess(mDstFilePath, F_OK)) {
+    NS_tsnprintf(mDstFilePath, sizeof(mDstFilePath)/sizeof(mDstFilePath[0]),
       NS_T("%s/%s"), sourcePath, alternateFileName);
   }
 
-  logFP = NS_tfopen(logFile, append ? NS_T("a") : NS_T("w"));
+  logFP = NS_tfopen(mDstFilePath, append ? NS_T("a") : NS_T("w"));
+#endif
 }
 
 void UpdateLog::Finish()
 {
   if (!logFP)
     return;
 
   fclose(logFP);
   logFP = nullptr;
+
+#ifdef XP_WIN
+  // When the log file already exists then the elevated updater has already
+  // written the log file and the temp file for the log should be discarded.
+  if (!NS_taccess(mDstFilePath, F_OK)) {
+    DeleteFileW(mTmpFilePath);
+  } else {
+    MoveFileW(mTmpFilePath, mDstFilePath);
+  }
+#endif
 }
 
 void UpdateLog::Flush()
 {
   if (!logFP)
     return;
 
   fflush(logFP);
diff --git a/toolkit/mozapps/update/common/updatelogging.h b/toolkit/mozapps/update/common/updatelogging.h
--- a/toolkit/mozapps/update/common/updatelogging.h
+++ b/toolkit/mozapps/update/common/updatelogging.h
@@ -27,17 +27,18 @@ public:
   ~UpdateLog()
   {
     Finish();
   }
 
 protected:
   UpdateLog();
   FILE *logFP;
-  NS_tchar* sourcePath;
+  NS_tchar mTmpFilePath[MAXPATHLEN];
+  NS_tchar mDstFilePath[MAXPATHLEN];
 };
 
 #define LOG_WARN(args) UpdateLog::GetPrimaryLog().WarnPrintf args
 #define LOG(args) UpdateLog::GetPrimaryLog().Printf args
 #define LogInit(PATHNAME_, FILENAME_) \
   UpdateLog::GetPrimaryLog().Init(PATHNAME_, FILENAME_, 0, false)
 #define LogInitAppend(PATHNAME_, FILENAME_, ALTERNATE_) \
   UpdateLog::GetPrimaryLog().Init(PATHNAME_, FILENAME_, ALTERNATE_, true)
diff --git a/toolkit/mozapps/update/tests/unit_aus_update/head_update.js b/toolkit/mozapps/update/tests/unit_aus_update/head_update.js
--- a/toolkit/mozapps/update/tests/unit_aus_update/head_update.js
+++ b/toolkit/mozapps/update/tests/unit_aus_update/head_update.js
@@ -1248,16 +1248,51 @@ function getTestDirPath() {
  * @return  The nsIFile for the file in the test data directory.
  * @throws  If the file or directory does not exist.
  */
 function getTestDirFile(aRelPath) {
   let relpath = getTestDirPath() + (aRelPath ? aRelPath : "");
   return do_get_file(relpath, false);
 }
 
+/**
+ * Helper function for getting the nsIFile for the maintenance service
+ * directory on Windows.
+ *
+ * @return  The nsIFile for the maintenance service directory.
+ */
+function getMaintSvcDir() {
+  if (!IS_WIN) {
+    do_throw("Windows only function called by a different platform!");
+  }
+
+  const CSIDL_PROGRAM_FILES = 0x26;
+  const CSIDL_PROGRAM_FILESX86 = 0x2A;
+  // This will return an empty string on our Win XP build systems.
+  let maintSvcDir = getSpecialFolderDir(CSIDL_PROGRAM_FILESX86);
+  if (maintSvcDir) {
+    maintSvcDir.append("Mozilla Maintenance Service");
+    debugDump("using CSIDL_PROGRAM_FILESX86 - maintenance service install " +
+              "directory path: " + maintSvcDir.path);
+  }
+  if (!maintSvcDir || !maintSvcDir.exists()) {
+    maintSvcDir = getSpecialFolderDir(CSIDL_PROGRAM_FILES);
+    if (maintSvcDir) {
+      maintSvcDir.append("Mozilla Maintenance Service");
+      debugDump("using CSIDL_PROGRAM_FILES - maintenance service install " +
+                "directory path: " + maintSvcDir.path);
+    }
+  }
+  if (!maintSvcDir) {
+    do_throw("Unable to find the maintenance service install directory");
+  }
+
+  return maintSvcDir;
+}
+
 #ifdef XP_WIN
 function getSpecialFolderDir(aCSIDL) {
   AUS_Cu.import("resource://gre/modules/ctypes.jsm");
   let lib = ctypes.open("shell32");
   let SHGetSpecialFolderPath = lib.declare("SHGetSpecialFolderPathW",
                                            ctypes.winapi_abi,
                                            ctypes.bool, /* bool(return) */
                                            ctypes.int32_t, /* HWND hwndOwner */
@@ -1890,33 +1925,17 @@ function copyFileToTestAppDir(aFileRelPa
  * @param  aSkipTest
  *         Whether to skip this test if the installed maintenance service
  *         isn't the same as the build's maintenance service. This is a
  *         temporary workaround until all build systems grant write access to
  *         the maintenance service install directory so the tests can copy the
  *         version of the maintenance service that should be tests.
  */
 function attemptServiceInstall(aSkipTest) {
-  const CSIDL_PROGRAM_FILES = 0x26;
-  const CSIDL_PROGRAM_FILESX86 = 0x2A;
-  // This will return an empty string on our Win XP build systems.
-  let maintSvcDir = getSpecialFolderDir(CSIDL_PROGRAM_FILESX86);
-  if (maintSvcDir) {
-    maintSvcDir.append("Mozilla Maintenance Service");
-    logTestInfo("using CSIDL_PROGRAM_FILESX86 - maintenance service install " +
-                "directory path: " + maintSvcDir.path);
-  }
-  if (!maintSvcDir || !maintSvcDir.exists()) {
-    maintSvcDir = getSpecialFolderDir(CSIDL_PROGRAM_FILES);
-    if (maintSvcDir) {
-      maintSvcDir.append("Mozilla Maintenance Service");
-      logTestInfo("using CSIDL_PROGRAM_FILES - maintenance service install " +
-                  "directory path: " + maintSvcDir.path);
-    }
-  }
+  let maintSvcDir = getMaintSvcDir();
   if (!maintSvcDir || !maintSvcDir.exists()) {
     do_throw("maintenance service install directory doesn't exist!");
   }
   let oldMaintSvcBin = maintSvcDir.clone();
   oldMaintSvcBin.append(FILE_MAINTENANCE_SERVICE_BIN);
   if (!oldMaintSvcBin.exists()) {
     do_throw("maintenance service install directory binary doesn't exist! " +
              "Path: " + oldMaintSvcBin.path);
@@ -1983,20 +2002,17 @@ function runUpdateUsingService(aInitialS
   // Check the service logs for a successful update
   function checkServiceLogs(aOriginalContents) {
     let contents = readServiceLogFile();
     logTestInfo("the contents of maintenanceservice.log:\n" + contents + "\n");
     do_check_neq(contents, aOriginalContents);
     do_check_neq(contents.indexOf(LOG_SVC_SUCCESSFUL_LAUNCH), -1);
   }
   function readServiceLogFile() {
-    let file = AUS_Cc["@mozilla.org/file/directory_service;1"].
-               getService(AUS_Ci.nsIProperties).
-               get("CmAppData", AUS_Ci.nsIFile);
-    file.append("Mozilla");
+    let file = getMaintSvcDir();
     file.append("logs");
     file.append("maintenanceservice.log");
     return readFile(file);
   }
   function waitServiceApps() {
     // maintenanceservice_installer.exe is started async during updates.
     waitForApplicationStop("maintenanceservice_installer.exe");
     // maintenanceservice_tmp.exe is started async from the service installer.
diff --git a/toolkit/mozapps/update/updater/updater.cpp b/toolkit/mozapps/update/updater/updater.cpp
--- a/toolkit/mozapps/update/updater/updater.cpp
+++ b/toolkit/mozapps/update/updater/updater.cpp
@@ -59,17 +59,22 @@
 
 // Amount of the progress bar to use in each of the 3 update stages,
 // should total 100.0.
 #define PROGRESS_PREPARE_SIZE 20.0f
 #define PROGRESS_EXECUTE_SIZE 75.0f
 #define PROGRESS_FINISH_SIZE   5.0f
 
 // Amount of time in ms to wait for the parent process to close
-#define PARENT_WAIT 5000
+#ifdef DEBUG
+// Use a large value for debug builds since the xpcshell tests take a long time.
+#define PARENT_WAIT 30000
+#else
+#define PARENT_WAIT 10000
+#endif
 #define IMMERSIVE_PARENT_WAIT 15000
 
 #if defined(XP_MACOSX)
 // These functions are defined in launchchild_osx.mm
 void LaunchChild(int argc, char **argv);
 void LaunchMacPostProcess(const char* aAppBundle);
 #endif
 
@@ -1849,30 +1854,52 @@ LaunchCallbackApp(const NS_tchar *workin
 #else
 # warning "Need implementaton of LaunchCallbackApp"
 #endif
 }
 
 static bool
 WriteStatusFile(const char* aStatus)
 {
-  NS_tchar filename[MAXPATHLEN];
+  NS_tchar filename[MAXPATHLEN] = {NS_T('\0')};
+#if defined(XP_WIN)
+  // The temp file is not removed on failure since there is client code that
+  // will remove it.
+  GetTempFileNameW(gPatchDirPath, L"sta", 0, filename);
+#else
   NS_tsnprintf(filename, sizeof(filename)/sizeof(filename[0]),
                NS_T("%s/update.status"), gPatchDirPath);
+#endif
 
   // Make sure that the directory for the update status file exists
-  if (ensure_parent_dir(filename))
+  if (ensure_parent_dir(filename)) {
     return false;
-
-  AutoFile file(NS_tfopen(filename, NS_T("wb+")));
-  if (file == nullptr)
+  }
+
+  // This is scoped to make the AutoFile close the file so it is possible to
+  // move the temp file to the update.status file on Windows.
+  {
+    AutoFile file(NS_tfopen(filename, NS_T("wb+")));
+    if (file == nullptr) {
+      return false;
+    }
+
+    if (fwrite(aStatus, strlen(aStatus), 1, file) != 1) {
+      return false;
+    }
+  }
+
+#if defined(XP_WIN)
+  NS_tchar dstfilename[MAXPATHLEN] = {NS_T('\0')};
+  NS_tsnprintf(dstfilename, sizeof(dstfilename)/sizeof(dstfilename[0]),
+               NS_T("%s\\update.status"), gPatchDirPath);
+  if (MoveFileExW(filename, dstfilename, MOVEFILE_REPLACE_EXISTING) == 0) {
     return false;
-
-  if (fwrite(aStatus, strlen(aStatus), 1, file) != 1)
-    return false;
+  }
+#endif
 
   return true;
 }
 
 static void
 WriteStatusFile(int status)
 {
   const char *text;
@@ -2756,24 +2783,24 @@ int NS_main(int argc, NS_tchar **argv)
             lastFallbackError = FALLBACKKEY_SERVICE_NO_STOP_ERROR;
             useService = false;
           }
         } else {
           lastFallbackError = FALLBACKKEY_LAUNCH_ERROR;
         }
       }
 
-      // If the service can't be used when staging and update, make sure that
+      // If the service can't be used when staging an update, make sure that
       // the UAC prompt is not shown! In this case, just set the status to
       // pending and the update will be applied during the next startup.
       if (!useService && sStagedUpdate) {
         if (updateLockFileHandle != INVALID_HANDLE_VALUE) {
           CloseHandle(updateLockFileHandle);
         }
-        WriteStatusPending(gPatchDirPath);
+        WriteStatusFile("pending");
         return 0;
       }
 
       // If we started the service command, and it finished, check the
       // update.status file to make sure it succeeded, and if it did
       // we need to manually start the PostUpdate process from the
       // current user's session of this unelevated updater.exe the
       // current process is running as.
diff --git a/toolkit/xre/nsAppRunner.h b/toolkit/xre/nsAppRunner.h
--- a/toolkit/xre/nsAppRunner.h
+++ b/toolkit/xre/nsAppRunner.h
@@ -100,20 +100,16 @@ WriteConsoleLog();
 #ifdef XP_WIN
 void
 UseParentConsole();
 
 BOOL
 WinLaunchChild(const wchar_t *exePath, int argc,
                char **argv, HANDLE userToken = nullptr,
                HANDLE *hProcess = nullptr);
-BOOL
-WriteStatusPending(LPCWSTR updateDirPath);
-BOOL
-WriteStatusApplied(LPCWSTR updateDirPath);
 #endif
 
 #define NS_NATIVEAPPSUPPORT_CONTRACTID "@mozilla.org/toolkit/native-app-support;1"
 
 namespace mozilla {
 namespace startup {
 extern GeckoProcessType sChildProcessType;
 }
