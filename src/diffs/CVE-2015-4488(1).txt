# HG changeset patch
# User Daniel Holbert <dholbert@cs.stanford.edu>
# Parent  ce210e31b92daac8f7a2ae7bf688f90839fc3a84

diff --git a/dom/smil/nsSMILCSSValueType.cpp b/dom/smil/nsSMILCSSValueType.cpp
--- a/dom/smil/nsSMILCSSValueType.cpp
+++ b/dom/smil/nsSMILCSSValueType.cpp
@@ -23,16 +23,19 @@ using namespace mozilla::dom;
 using mozilla::StyleAnimationValue;
 
 /*static*/ nsSMILCSSValueType nsSMILCSSValueType::sSingleton;
 
 struct ValueWrapper {
   ValueWrapper(nsCSSProperty aPropID, const StyleAnimationValue& aValue) :
     mPropID(aPropID), mCSSValue(aValue) {}
 
+  // XXXdholbert Temporarily deleting operator=, to audit its usage.
+  ValueWrapper& operator=(const ValueWrapper& aOther) = delete;
+
   nsCSSProperty mPropID;
   StyleAnimationValue mCSSValue;
 };
 
 // Helper Methods
 // --------------
 static const StyleAnimationValue*
 GetZeroValueForUnit(StyleAnimationValue::Unit aUnit)
@@ -166,17 +169,22 @@ nsSMILCSSValueType::Assign(nsSMILValue& 
   ValueWrapper* destWrapper = ExtractValueWrapper(aDest);
 
   if (srcWrapper) {
     if (!destWrapper) {
       // barely-initialized dest -- need to alloc & copy
       aDest.mU.mPtr = new ValueWrapper(*srcWrapper);
     } else {
       // both already fully-initialized -- just copy straight across
-      *destWrapper = *srcWrapper;
+      // XXXdholbert TEMPORARILY COMMENTING OUT
+      // There *could* be self-assignment here, **if** Assign() were
+      // called with the same aDest & aSrc. However, that will never happen,
+      // because this is only invoked via nsSMILValue::operator=, and that
+      // function has an explicit guard against self-assignment.
+      //  *destWrapper = *srcWrapper;
     }
   } else if (destWrapper) {
     // fully-initialized dest, barely-initialized src -- clear dest
     delete destWrapper;
     aDest.mU.mPtr = destWrapper = nullptr;
   } // else, both are barely-initialized -- nothing to do.
 
   return NS_OK;
@@ -237,17 +245,20 @@ nsSMILCSSValueType::Add(nsSMILValue& aDe
   const StyleAnimationValue* destValue = destWrapper ?
     &destWrapper->mCSSValue : nullptr;
   if (!FinalizeStyleAnimationValues(valueToAdd, destValue)) {
     return NS_ERROR_FAILURE;
   }
   // Did FinalizeStyleAnimationValues change destValue?
   // If so, update outparam to use the new value.
   if (destWrapper && &destWrapper->mCSSValue != destValue) {
-    destWrapper->mCSSValue = *destValue;
+    // XXXdholbert TEMPORARILY COMMENTING OUT
+    // Definitely no self-assignment here; the "if" check above ensures that
+    // these instances are different.
+    // destWrapper->mCSSValue = *destValue;
   }
 
   // Handle barely-initialized "zero" destination.
   if (!destWrapper) {
     aDest.mU.mPtr = destWrapper =
       new ValueWrapper(property, *destValue);
   }
 
diff --git a/layout/style/StyleAnimationValue.cpp b/layout/style/StyleAnimationValue.cpp
--- a/layout/style/StyleAnimationValue.cpp
+++ b/layout/style/StyleAnimationValue.cpp
@@ -3556,16 +3556,17 @@ StyleAnimationValue::StyleAnimationValue
 }
 
 StyleAnimationValue::StyleAnimationValue(nscolor aColor, ColorConstructorType)
 {
   mUnit = eUnit_Color;
   mValue.mColor = aColor;
 }
 
+/*
 StyleAnimationValue&
 StyleAnimationValue::operator=(const StyleAnimationValue& aOther)
 {
   FreeValue();
 
   mUnit = aOther.mUnit;
   switch (mUnit) {
     case eUnit_Null:
@@ -3636,16 +3637,17 @@ StyleAnimationValue::operator=(const Sty
       MOZ_ASSERT(aOther.mValue.mString, "expecting non-null string");
       mValue.mString = aOther.mValue.mString;
       mValue.mString->AddRef();
       break;
   }
 
   return *this;
 }
+*/
 
 void
 StyleAnimationValue::SetNormalValue()
 {
   FreeValue();
   mUnit = eUnit_Normal;
 }
 
diff --git a/layout/style/StyleAnimationValue.h b/layout/style/StyleAnimationValue.h
--- a/layout/style/StyleAnimationValue.h
+++ b/layout/style/StyleAnimationValue.h
@@ -318,17 +318,18 @@ public:
   }
 
   explicit StyleAnimationValue(Unit aUnit = eUnit_Null) : mUnit(aUnit) {
     NS_ASSERTION(aUnit == eUnit_Null || aUnit == eUnit_Normal ||
                  aUnit == eUnit_Auto || aUnit == eUnit_None,
                  "must be valueless unit");
   }
   StyleAnimationValue(const StyleAnimationValue& aOther)
-    : mUnit(eUnit_Null) { *this = aOther; }
+    : mUnit(eUnit_Null) {/* XXXdholbert commenting out; no self-assignment here.
+                            *this = aOther; */ }
   enum IntegerConstructorType { IntegerConstructor };
   StyleAnimationValue(int32_t aInt, Unit aUnit, IntegerConstructorType);
   enum CoordConstructorType { CoordConstructor };
   StyleAnimationValue(nscoord aLength, CoordConstructorType);
   enum PercentConstructorType { PercentConstructor };
   StyleAnimationValue(float aPercent, PercentConstructorType);
   enum FloatConstructorType { FloatConstructor };
   StyleAnimationValue(float aFloat, FloatConstructorType);
@@ -353,17 +354,18 @@ public:
   void SetAndAdoptCSSValuePairValue(nsCSSValuePair *aValue, Unit aUnit);
   void SetAndAdoptCSSValueTripletValue(nsCSSValueTriplet *aValue, Unit aUnit);
   void SetAndAdoptCSSRectValue(nsCSSRect *aValue, Unit aUnit);
   void SetAndAdoptCSSValueListValue(nsCSSValueList *aValue, Unit aUnit);
   void SetAndAdoptCSSValuePairListValue(nsCSSValuePairList *aValue);
 
   void SetTransformValue(nsCSSValueSharedList* aList);
 
-  StyleAnimationValue& operator=(const StyleAnimationValue& aOther);
+  // XXXdholbert Temporarily deleting operator=, to audit its usage.
+  StyleAnimationValue& operator=(const StyleAnimationValue& aOther) = delete;
 
   bool operator==(const StyleAnimationValue& aOther) const;
   bool operator!=(const StyleAnimationValue& aOther) const
     { return !(*this == aOther); }
 
 private:
   void FreeValue();
 
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -737,19 +737,22 @@ nsAnimationManager::BuildSegment(Infalli
       // (If this is ever a performance problem, we could add a
       // CanInterpolate method, but it seems fine for now.)
       !StyleAnimationValue::Interpolate(aProperty, fromValue, toValue,
                                         0.5, dummyValue)) {
     return false;
   }
 
   AnimationPropertySegment &segment = *aSegments.AppendElement();
-
-  segment.mFromValue = fromValue;
-  segment.mToValue = toValue;
+  // XXXdholbert TEMPORARILY COMMENTING OUT
+  // These are OK because segment lives in aSegments' nsTArray buffer, whereas
+  // fromValue/toValue are local stack variables. So no self-assignment going
+  // on here.
+  //  segment.mFromValue = fromValue;
+  //  segment.mToValue = toValue;
   segment.mFromKey = aFromKey;
   segment.mToKey = aToKey;
   const nsTimingFunction *tf;
   if (aFromDeclaration &&
       aFromDeclaration->HasProperty(eCSSProperty_animation_timing_function)) {
     tf = &aFromContext->StyleDisplay()->mAnimations[0].GetTimingFunction();
   } else {
     tf = &aAnimation.GetTimingFunction();
diff --git a/layout/style/nsTransitionManager.cpp b/layout/style/nsTransitionManager.cpp
--- a/layout/style/nsTransitionManager.cpp
+++ b/layout/style/nsTransitionManager.cpp
@@ -533,40 +533,50 @@ nsTransitionManager::ConsiderStartingTra
     // function, so reduce them along with the duration, but don't
     // reduce positive delays.
     if (delay < 0.0f) {
       delay *= valuePortion;
     }
 
     duration *= valuePortion;
 
-    startForReversingTest = oldPT->Properties()[0].mSegments[0].mToValue;
+    // XXXdholbert temporarily commenting out
+    // Definitely no self-assignment here; startForReversingTest is a local
+    // stack var, whereas the rhs of this assignment lives off in some struct.
+    // startForReversingTest = oldPT->Properties()[0].mSegments[0].mToValue;
     reversePortion = valuePortion;
   }
 
   AnimationTiming timing;
   timing.mIterationDuration = TimeDuration::FromMilliseconds(duration);
   timing.mDelay = TimeDuration::FromMilliseconds(delay);
   timing.mIterationCount = 1;
   timing.mDirection = NS_STYLE_ANIMATION_DIRECTION_NORMAL;
   timing.mFillMode = NS_STYLE_ANIMATION_FILL_MODE_BACKWARDS;
 
   nsRefPtr<ElementPropertyTransition> pt =
     new ElementPropertyTransition(aElement->OwnerDoc(), aElement,
                                   aNewStyleContext->GetPseudoType(), timing);
-  pt->mStartForReversingTest = startForReversingTest;
+  // XXXdholbert temporarily commenting out
+  // Definitely no self-assignment here; startForReversingTest is a local stack
+  // var, whereas |pt| is a heap-allocated thing, which brings along its own
+  // mStartForReversingTest.
+  // pt->mStartForReversingTest = startForReversingTest;
   pt->mReversePortion = reversePortion;
 
   AnimationProperty& prop = *pt->Properties().AppendElement();
   prop.mProperty = aProperty;
   prop.mWinsInCascade = true;
 
   AnimationPropertySegment& segment = *prop.mSegments.AppendElement();
-  segment.mFromValue = startValue;
-  segment.mToValue = endValue;
+  // XXXdholbert temporarily commenting out
+  // Definitely no self-assignment here; |segment| lives in prop.mSegments'
+  // buffer, whereas startValue/endValue are local stack vars.
+  // segment.mFromValue = startValue;
+  // segment.mToValue = endValue;
   segment.mFromKey = 0;
   segment.mToKey = 1;
   segment.mTimingFunction.Init(tf);
 
   nsRefPtr<CSSTransition> animation = new CSSTransition(timeline);
   // The order of the following two calls is important since PlayFromStyle
   // will add the animation to the PendingAnimationTracker of its effect's
   // document. When we come to make effect writeable (bug 1049975) we should
