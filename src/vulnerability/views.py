from django.shortcuts import render_to_response
from django.contrib import auth
from django.http import HttpResponse, HttpResponseRedirect
from vulnerability.models import CVE, REUSE, CVSS, EXPLOIT, INFO, FUNC, FEATURE, REUSEFEATURE,DIFFFEATURE
from django import forms
# from vulnerability.models import RegisterForm
from django.template import RequestContext
from django.db import connection
import re
from _datetime import datetime
PAGENUMS = 20

class PageIndex:
    def __init__(self):
        self.sum = 0
        self.curIndex = 0
        self.endIndex = 0
        self.lastPageIndex = 0
        self.firstPageNum = 1
        self.curPageNum = 1
        self.endPageNum = 1
        self.pages = range(self.curPageNum, self.curPageNum + 10)
        self.page = 1  # only for pages
        self.queryString = None
    def getPageIndex(self):  # from pages Num to Index
        index = (self.page - 1) * PAGENUMS
        self.page += 1
        return index
    def getEndIndex(self):
        endIndex = int(self.curIndex) + PAGENUMS - 1
        if endIndex > self.sum:
            return self.sum
        else:
            return endIndex
class VulnerabilityDetail:
    def __init__(self):
        self.CVE = CVE
        self.CVSS = CVSS
        self.INFO = []
        self.EXPLOITS = []
        self.REUSES = []
        self.FUNC = []
def getVulnerabilityDetail(cveid, req):   
    errors = [] 
    vulnerabilityDetail = VulnerabilityDetail()
    try:
        cve = CVE.objects.get(cve_id=cveid)
        print(cve)
        vulnerabilityDetail.CVE = cve
        vulnerabilityDetail.CVSS = CVSS.objects.filter(cveid=cve)
        vulnerabilityDetail.EXPLOITS = EXPLOIT.objects.filter(cve=cve)
        vulnerabilityDetail.INFO = INFO.objects.filter(cve=cve)
        for info in vulnerabilityDetail.INFO:
            info.feature = DIFFFEATURE.objects.filter(info_id=info)
            reuses = REUSE.objects.filter(info_id=info)
            for reuse in reuses:
                reuse.feature = REUSEFEATURE.objects.filter(reuse=reuse)
                vulnerabilityDetail.REUSES.append(reuse)
        return vulnerabilityDetail
    except Exception as err:
        errors.append(err) 
        print(errors) 
        return None
                 
def display_meta(req):
    return render_to_response('add_vuln.html')
# Create your views here.

def index(req):
    return render_to_response('index.html' , {'user':req.user})

def vulnerabilityNVD(req):
    errors = []
    try:
        vulnerabilities = CVE.objects.all()
        for vuln in vulnerabilities:
            vuln.exploits = vuln.exploit_set.count()
        return render_to_response('vulnerabilityNVD.html', {\
                                                    'vulnerabilities':vulnerabilities, \
                                                    'user':req.user, \
                                                     })
    except Exception as err:
        errors.append(err)  
        return render_to_response('vulnerabilityNVD.html', {'errors': errors})
def vulnerabilityPatch(req):
    errors = []
    try:
    # vulnerabilities with patch
        vulnerabilitiesWithPatch = []
        infos = INFO.objects.exclude(diff_link='')
        for info in infos:
            if info.cve not in vulnerabilitiesWithPatch:
                vulnerabilitiesWithPatch.append(info.cve)
        sumPatch = len(vulnerabilitiesWithPatch)
        print(vulnerabilitiesWithPatch)
        pageInfo = pagination_vul(int(sumPatch), req)
        for vuln in vulnerabilitiesWithPatch:
            vuln.exploits = vuln.exploit_set.count()
        print(vulnerabilitiesWithPatch)
        return render_to_response('vulnerabilityWithPatch.html', {\
                                                    'vulnerabilities':vulnerabilitiesWithPatch, \
                                                    'user':req.user, \
                                                     'pageInfo':pageInfo})
    except Exception as err:
        errors.append(err)
        return render_to_response('vulnerabilityWithPatch.html', {'errors': errors})

def vulnerabilityReuse(req):    
    errors = []
    try:
        reuses = REUSE.objects.all()
        vulnerabilitiesWithReuse = []
        for reuse in reuses:
            if reuse.info_id.cve not in vulnerabilitiesWithReuse:
                vulnerabilitiesWithReuse.append(reuse.info_id.cve)
        sumReuse = len(vulnerabilitiesWithReuse)
        print("reuse")
        print(vulnerabilitiesWithReuse)
        pageInfo = pagination_vul(int(sumReuse), req) 
        for vuln in vulnerabilitiesWithReuse:
            vuln.exploits = vuln.exploit_set.count()
        print("reuse")
        print(vulnerabilitiesWithReuse)
        return render_to_response('vulnerabilityWithReuse.html', {\
                                                    'vulnerabilities':vulnerabilitiesWithReuse, \
                                                    'user':req.user, \
                                                     'pageInfo':pageInfo})
    except Exception as err:
        errors.append(err)  
        return render_to_response('vulnerabilityWithReuse.html', {'errors': errors})
def searchAdvanced(req):
    
    return render_to_response('search_advanced.html')
    
def importBatch(req):
    return render_to_response('importBatch.html')

class UserForm(forms.Form):
    username = forms.CharField(max_length=20, label=u"username")
    password = forms.CharField(widget=forms.PasswordInput, max_length=20, label=u"password")
    
def login(req):
    
    if req.method == "POST":
        user_form = UserForm(req.POST)
        if user_form.is_valid():
            username = user_form.cleaned_data['username']
            password = user_form.cleaned_data['password']
            print ("valid")
            user = auth.authenticate(username=username, password=password)
            print("user")
            print(user)
            print(username + password)
            if user:
                print("password" + user.password)
                auth.login(req, user) 
                response = render_to_response("index.html", RequestContext(req))
                if 'next' in req.GET:
                        return HttpResponseRedirect(req.GET["next"])
                # 将username写入浏览器cookie,失效时间为3600
                return response
            else:
                return render_to_response("login.html", RequestContext(req, {'wrong':"wrong username or password"}))
        else:
            return render_to_response("login.html", RequestContext(req, {'wrong':"please input username and password"}))
    else:
        return render_to_response("login.html", RequestContext(req))
    

def logout(req):
    auth.logout(req)
    logout = "logout"
    return render_to_response("index.html", {'logout':logout}) 

class RegistrationForm(forms.Form):
    username = forms.CharField(label=u'username', max_length=100)
    password1 = forms.CharField(widget=forms.PasswordInput, max_length=20, label=u"password1")
    password2 = forms.CharField(widget=forms.PasswordInput, max_length=20, label=u"password2")
    email = forms.EmailField(label=u'email')
    
def registration(req):
    from django.contrib.auth.models import User
    if req.method == "POST":
        uf = RegistrationForm(req.POST)
        if uf.is_valid():
            # get form
            username = uf.cleaned_data['username']
            password1 = uf.cleaned_data['password1']
            password2 = uf.cleaned_data['password2']
            email = uf.cleaned_data['email']
            errors = []
            if password1 != password2:
                errors.append("Entered passwords differ!")
                return render_to_response('registration.html', RequestContext(req, {'uf':uf, 'errors':errors})) 
            
            filterResult = User.objects.filter(username=username)  #c************  
            if len(filterResult) > 0:  
                errors.append("A username already exists")  
                return render_to_response('registration.html', RequestContext(req, {'uf':uf, 'errors':errors})) 
            # install to mysql
            # user = User.objects.create(username,email,password2)
            user = User.objects.create_user(username, email, password2)
            user.save()
            # login
            # login_user=auth.authenticate(username=username, password=password1)
            # auth.login(req, login_user) 
            # 返回注册成功页面
            return render_to_response('success.html', RequestContext(req, {'tips':"Registration successful.Please login" + password2}))
        else:
            errors.append("Please input username、password and email")
            return render_to_response('registration.html', RequestContext(req, {'uf':uf, 'errors':errors}))    
    else:
        uf = RegistrationForm()
        return render_to_response('registration.html', context_instance=RequestContext(req, {'uf':uf}))

def forum(req):
    return render_to_response('forum.html', {'user':req.user})

def detail_vul(req):
    errors = []
    try:
        if 'q' in req.GET:
            q = req.GET['q']
            if not validCVE(q):
                errors.append('Enter a search term.')
            else:
                if not re.match('^CVE-', q):
                    q = 'CVE-' + q
            vulnerabilityDetail = getVulnerabilityDetail(q, req)
            if vulnerabilityDetail == None:
                errors.append("No Term Found")
                return render_to_response('detail_vul.html', {'errors': errors, 'query':q})
            return render_to_response('detail_vul.html', {'query':q, 'vulnerabilityDetail':vulnerabilityDetail})
        return render_to_response('detail_vul.html', {'errors': errors})
    except Exception as err:
        errors.append(err)
        return render_to_response('detail_vul.html', {'errors': errors})
    

def validCVE(cveid):
    patt = '^(CVE-)?[0-9]{4}-[0-9]{1,39}$'
    m = re.match(patt, cveid)
    if not m:
        return False
    return True

def search_cve(req):
    errors = []
    query = []
    q = req.GET['q']
    if not q:
        errors.append('Enter a search term.')
    elif not validCVE(q):
        errors.append('Incorrect CVE ID, expected format: CVE-[0-9]{4}-[0-9]{1,39} or [0-9]{4}-[0-9]{1,39}')
    else:            
        query.append(q)
        try:
            vulnerabilities = CVE.objects.filter(cve_id__contains=q)
            for vuln in vulnerabilities:
                vuln.exploits = vuln.exploit_set.count()
            return render_to_response('search_results.html', {'vulnerabilities':vulnerabilities, 'user':req.user, 'q':q})
        except:
            errors.append("ERROR")
    return render_to_response('search_results.html', {'errors': errors, 'q':q, 'user':req.user})      

def search_vul(req):
    if 'q' in req.GET:  # search 
        return search_cve(req)
    elif 'ad_q' in req.GET:  # advanced search
        return search_advanced(req)
    # elif 'Analysis' in req.GET:  # analysis
    #    return analysis(req)
    else:
        return render_to_response('404.html') 

def search_advanced(req):
    errors = []
    query = []
    vulnerabilities = []
    cursor = connection.cursor()
    sql = "select * from vulnerability_cve"
    condition = None
    # CveIdentifier CveIdentifierTextBox
    CveIdentifier = req.GET['CveIdentifierTextBox']
    if CveIdentifier:
        if not validCVE(CveIdentifier):
            errors.append('Incorrect CVE ID, expected format: CVE-[0-9]{4}-[0-9]{1,39} or [0-9]{4}-[0-9]{1,39}')
        else:
            temp = "CVEID rlike '[CVE-]?" + CveIdentifier + "'" 
            condition = add_condition(condition, temp)
            query.append('CVEID:' + CveIdentifier)
    
    # Keyword QueryTextBox    
    keyword = req.GET['QueryTextBox']
    if keyword:
        if len(keyword) > 20:
            errors.append('Please submit keyword 20 characters or shorter')
        else:
            temp = "Description rlike '.*" + keyword + ".*'" 
            condition = add_condition(condition, temp)
            query.append('Description KeyWords:' + keyword)
            
    # cweid CweDropDownList    
    cweid = req.GET['CweDropDownList']
    if cweid != "":
        cweid = cweid[4:]
        if (cweid == "CWE-noinfo") or (cweid == 'CWE-Other'):
            temp = "cweid is null"
        else:
            temp = "CWEID = '" + cweid + "'"
            query.append('CWEID:' + "Get the CWE Value from ID is not done .we have no cwe dictionary yet")
        condition = add_condition(condition, temp)
        
    # Vendor CPEVendorTextBox
    vendor = req.GET['CPEVendorTextBox']
    if vendor:
        if len(vendor) > 20:
            errors.append('Please submit Vendor 20 characters or shorter')
        else:  # if has cpe then use cpe sql
            sql = "select * from vulnerability_cve"
            temp = "company= '" + vendor + "'"
            condition = add_condition(condition, temp)
            query.append('Vendor:' + vendor)
    # Product CPEProductTextBox
    product = req.GET['CPEProductTextBox']
    if product:
        if len(product) > 20:
            errors.append('Please submit Product 20 characters or shorter')
        else:  # if has cpe then use cpe sql
            sql = "select * from vulnerability_cve"
            temp = "name rlike '.*" + product + ".*'"
            condition = add_condition(condition, temp)
            query.append('Product:' + product)
    # version CPEVersionTextBox
    version = req.GET['CPEVersionTextBox']
    if version:
        if not product:
            errors.append('Version needs Product first')
        elif len(version) > 20:
            errors.append('Please submit Version 20 characters or shorter')
        else:
            sql = "select * from vulnerability_cve"
            temp = "SoftwareVersion = '" + version + "'"
            condition = add_condition(condition, temp)
            query.append('Version:' + version)
    # Modify date Range
    # startTime ModDateStartMonthDropDown ModDateStartYearDropDown
    flag = None
    month = req.GET['ModDateStartMonthDropDown']
    year = req.GET['ModDateStartYearDropDown']
    if month != "0" and year != "0":
        startTime = year + "-" + month.zfill(2) + "-01T00:00.000-00:00"
        temp = "update_date >= '" + startTime + "'"
        condition = add_condition(condition, temp)
        query.append('Modified Date Start Time:' + year + "-" + month.zfill(2))
    elif (month == '0' and year != '0') or (month != '0' and year == '0'):
        flag = 1
    # endTime  ModDateEndMonthDropDown ModDateEndYearDropDown
    month = req.GET['ModDateEndMonthDropDown']
    year = req.GET['ModDateEndYearDropDown']
    if month != "0" and year != "0":
        endTime = year + "-" + month.zfill(2) + "-31T23:59.999-23:59"
        temp = "update_date <= '" + endTime + "'"
        condition = add_condition(condition, temp)
        query.append('Modified Date End Time:' + year + "-" + month.zfill(2))
    elif (month == '0' and year != '0') or (month != '0' and year == '0'):
        flag = 1 
    if flag != None:
        errors.append('Any dates chosen must select both Month and Year')
    # CVSS 
    # CvssSevBaseDropDown
    res = req.GET['CvssSevBaseDropDown']
    if res != "":
        if res == "LOW":
            low = 0
            high = 3
        elif res == "MEDIUM":
            low = 4
            high = 6
        elif res == "MEDIUM_HIGH":
            low = 4
            high = 10
        elif res == "HIGH":
            low = 7
            high = 10
        temp = "CVSS >= '%s' and CVSS <= '%s'" % (low, high)
        condition = add_condition(condition, temp)
        query.append('Severity (Base Score Range):' + str(res))
    
    if errors:
        return render_to_response('search_advanced.html', {'errors': errors})
    if condition:
        sql = sql + " where " + condition + " order by CVEID DESC"
    try:
        sql += ";"
        print(sql)
        cursor.execute(sql)
        # get data
        desc = cursor.description
        rows = [ dict(zip([col[0] for col in desc], row)) for row in cursor.fetchall()]
        
        rows = rows
        print(rows)
        for row in rows:
            vulnTemp = CVE     
            vulnTemp.cve_id = row['CVEID']
            print(vulnTemp.cve_id)
            vulnTemp.user = row['User']
            vulnTemp.cwe_id = row['CWEID']
            vulnTemp.cvss_id = row['CVSS']
            vulnTemp.update_date = row['update_date']
            vulnTemp.description = row['Description']
            vulnTemp.vuln_type = row['TYPE']
            vulnerabilities.append(vulnTemp)
        return render_to_response('search_results.html',
            {'vulnerabilities':vulnerabilities, 'q':query})
    except:
        errors.append('Execute sql error')
    finally:
        cursor.close()
    return render_to_response('search_advanced.html', {'errors': errors})

def add_condition(condition, str1):
    if condition:
        str1 = " and " + str1 
        condition += str1
    else:
        condition = str1
    return condition

def add_Save(req):
    curtime = datetime.now()
    errors = []
    if req.method == 'GET':  
        print("GET")  
        cve_id = req.GET['cve_id']
        cwe_id = req.GET['cwe_id']
        vuln_type = req.GET['vuln_type']
        cvss_id = req.GET['cvss_id']
        description = req.GET['description']
        user = req.GET['user']
        cveResult = CVE.objects.filter(cve_id=cve_id)
        if len(cveResult) > 0:
            errors.append("cve exists")
            return render_to_response('add_success.html', {'errors':errors})
        cve = CVE()
        cve.cve_id = cve_id
        cve.cwe_id = cwe_id
        cve.vuln_type = vuln_type
        cve.cvss_id = cvss_id
        cve.description = description
        cve.user = user
        cve.update_date = curtime
        cve.save()
    return render_to_response('add_success.html', {'errors':errors})

def pagination_vul(sum1, req):
    try:
        errors = []
        # page index info
        pageInfo = PageIndex()
        pageInfo.sum = sum1
        pageInfo.endPageNum = sum1 / PAGENUMS + 1
        # query string  
        if 'QUERY_STRING' in req.META:
            queryString = req.META['QUERY_STRING']
            re.sub('&startIndex.*$', '', queryString)
            pageInfo.queryString = queryString
        startIndex = 0
        if 'startIndex' in req.GET:
            startIndex = int(req.GET['startIndex'])  ###########take care of req
        pageInfo.curIndex = startIndex + 1  # page index start from 1,so it needs +1 there  
        pageInfo.endIndex = pageInfo.getEndIndex()
        if sum1 > PAGENUMS:
            pageInfo.lastPageIndex = sum1 - sum1 % PAGENUMS
        else:
            pageInfo.lastPageIndex = 0
        # page num info
        firstPageNum = 1
        if 'firstPageNum' in req.GET:
            firstPageNum = int(req.GET['firstPageNum'])
        lastPageNum = firstPageNum + 9
        if lastPageNum > pageInfo.endPageNum:
            lastPageNum = pageInfo.endPageNum
        pageInfo.curPageNum = startIndex / PAGENUMS + 1
        pageInfo.pages = range(firstPageNum, lastPageNum + 1)
        if pageInfo.curPageNum == lastPageNum:  # and pageInfo.curPageNum != pageInfo.endPageNum:#the last pageNum adjust nav bar
            lastPageNum = pageInfo.curPageNum + 5 
            if lastPageNum > pageInfo.endPageNum:
                lastPageNum = pageInfo.endPageNum
            firstPageNum = lastPageNum - 9
            if firstPageNum < 1:
                firstPageNum = 1
        elif pageInfo.curPageNum == firstPageNum:  # and pageInfo.curPageNum != 1:
            firstPageNum = pageInfo.curPageNum - 5
            if firstPageNum < 1:
                firstPageNum = 1
            lastPageNum = firstPageNum + 9
        elif pageInfo.curPageNum == 1:
            firstPageNum = 1
            lastPageNum = 10
            if lastPageNum > pageInfo.endPageNum:
                lastPageNum = pageInfo.endPageNum
        elif pageInfo.curPageNum == pageInfo.endPageNum:
            lastPageNum = pageInfo.endPageNum
            firstPageNum = pageInfo.curPageNum - 9
            if firstPageNum < 1:
                firstPageNum = 1
        pageInfo.page = firstPageNum
        pageInfo.pages = range(firstPageNum, lastPageNum + 1)
        pageInfo.firstPageNum = firstPageNum
        print(pageInfo.curIndex)
        print(pageInfo.endIndex)
        return pageInfo        
    except Exception as e:
        errors.append(e)
        return render_to_response('search_results.html', {'errors': errors})
        
def addVulnerability(req):
    if '_save' in req.GET: 
        return add_Save(req)
    else:
        return render_to_response('add_vuln.html')
     
def editVulnerability(req):
    if 'q' in req.GET:
        q = req.GET['q']
        vulnerability = CVE.objects.get(cve_id=q)
        return render_to_response('edit_vuln.html', {'vulnerability':vulnerability})
    elif '_update' in req.GET:
        cve_id = req.GET['cve_id']
        vulnerability = CVE.objects.get(cve_id=cve_id)
        vulnerability.cve_id = req.GET['cve_id']
        vulnerability.cwe_id = req.GET['cwe_id']
        vulnerability.vuln_type = req.GET['vuln_type']
        vulnerability.cvss_id = req.GET['cvss_id']
        vulnerability.description = req.GET['description']
        vulnerability.user = req.GET['user']
        vulnerability.save()
        return render_to_response("success.html")
    else:
        return render_to_response('edit_vuln.html')
def diffInfoShow(req):
    errors = []
    diffInfo=None
    try:
        if 'info' in req.GET:
            info=req.GET['info']
        diffInfo=INFO.objects.get(id=int(info))
        diffInfoList=[]
        if diffInfo.diff_link:
            diffInfoList=INFO.objects.filter(diff_link=diffInfo.diff_link)
        diffInfo.feature=DIFFFEATURE.objects.filter(info_id=diffInfo)
        with open(diffInfo.diff_file) as f:
            difftxt= f.read()
        return render_to_response('diffInfo.html', {'errors': errors,'info':diffInfo,'difftxt':difftxt,'diffList':diffInfoList})
    except Exception as err:
        errors.append(err)
        return render_to_response('diffInfo.html', {'errors': errors})

def download(req):
    from django.http import StreamingHttpResponse
    errors = []
    try:
        def file_iterator(file_name, chunk_size=512):
            with open(file_name) as f:
                while True:
                    c = f.read(chunk_size)
                    if c:
                        yield c
                    else:
                        break
        if 'file' in req.GET:
            filename=req.GET['file']
            m=filename.split('\\')
            response = StreamingHttpResponse(file_iterator(filename))
            response['Content-Type'] = 'application/octet-stream'
            str1='attachment;filename="diff_'+m[-1]+'"'
            response['Content-Disposition'] = str1.format(filename)
            return response
        
        if 'info'in req.GET:
            infoid=req.GET['info']
            func=req.GET['func']
            version=req.GET['version']
            info=INFO.objects.get(id=infoid)
            reuse=REUSE.objects.get(info_id=info,version=version,patch_func=func)
            response = StreamingHttpResponse(reuse.code)
            response['Content-Type'] = 'application/octet-stream'
            str1='attachment;filename="'+info.cve.cve_id+'_'+reuse.patch_func+'.txt"'
            response['Content-Disposition'] = str1.format()
            return response
    except Exception as err:
        errors.append(err)
        return HttpResponse("Download failed!")  
def featureShow(req):
    errors = []
    try:
        features=FEATURE.objects.all()
        return render_to_response('aboutFeature.html',{'features':features})
    except Exception as err:
        errors.append(err)
        return render_to_response('aboutFeature.html',{'errors':errors})