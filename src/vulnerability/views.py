from django.shortcuts import render_to_response
from django.contrib import auth
from django.http import HttpResponse, HttpResponseRedirect
from vulnerability.models import CVE, REUSE, CVSS, EXPLOIT, INFO, FUNC, FEATURE, REUSEFEATURE, DIFFFEATURE
from vulnerability.models import CREDIT, REWARDDIFF, DIFFSUBMIT
from vulnerability.models import EXPLOITSUBMIT, REWARDEXPLOIT, PROFILE
from vulnerability.models import REWARDCVE, CVESUBMIT
from django.contrib.auth.models import User
from django import forms
# from vulnerability.models import RegisterForm
from django.template import RequestContext
from django.db import connection
import re
import os
from django.db.models import Q
from _datetime import datetime
PAGENUMS = 20
DIFFFILENAME = 'difffile/'
DIFFIMPORTNAME = 'diff/'

class PageIndex:
    def __init__(self):
        self.sum = 0
        self.curIndex = 0
        self.endIndex = 0
        self.lastPageIndex = 0
        self.firstPageNum = 1
        self.curPageNum = 1
        self.endPageNum = 1
        self.pages = range(self.curPageNum, self.curPageNum + 10)
        self.page = 1  # only for pages
        self.queryString = None
    def getPageIndex(self):  # from pages Num to Index
        index = (self.page - 1) * PAGENUMS
        self.page += 1
        return index
    def getEndIndex(self):
        endIndex = int(self.curIndex) + PAGENUMS - 1
        if endIndex > self.sum:
            return self.sum
        else:
            return endIndex
class VulnerabilityDetail:
    def __init__(self):
        self.CVE = CVE
        self.CVSS = CVSS
        self.INFO = []
        self.EXPLOITS = []
        self.REUSES = []
        self.FUNC = []
def getVulnerabilityDetail(cveid, req):   
    errors = [] 
    vulnerabilityDetail = VulnerabilityDetail()
    try:
        cve = CVE.objects.get(cve_id=cveid)
        print(cve)
        vulnerabilityDetail.CVE = cve
        cvsss = CVSS.objects.filter(cveid=cve)
        for cvss in cvsss:
            cvss = handleCVSS(cvss)
        vulnerabilityDetail.CVSS = cvsss
        vulnerabilityDetail.EXPLOITS = EXPLOIT.objects.filter(cve=cve)
        vulnerabilityDetail.INFO = INFO.objects.filter(cve=cve)
        for info in vulnerabilityDetail.INFO:
            info.feature = DIFFFEATURE.objects.filter(info_id=info)
            reuses = REUSE.objects.filter(info_id=info)
            for reuse in reuses:
                reuse.feature = REUSEFEATURE.objects.filter(reuse=reuse)
                vulnerabilityDetail.REUSES.append(reuse)
        return vulnerabilityDetail
    except Exception as err:
        errors.append(err) 
        print(errors) 
        return None
def handleCVSS(cvss):
    if(cvss.accessVector == 'L'):
        cvss.accessVector = "Local"
    if(cvss.accessVector == 'A'):
        cvss.accessVector = "Adjacent Network"
    if(cvss.accessVector == 'N'):
        cvss.accessVector = "Network"
        
    if(cvss.accessComplexity == 'H'):
        cvss.accessComplexity = "High"
    if(cvss.accessComplexity == 'M'):
        cvss.accessComplexity = "Medium"
    if(cvss.accessComplexity == 'L'):
        cvss.accessComplexity = "Low"
        
    if(cvss.authentication == 'M'):
        cvss.authentication = "Multiple"
    if(cvss.authentication == 'S'):
        cvss.authentication = "Single"
    if(cvss.authentication == 'N'):
        cvss.authentication = "None"
        
    if(cvss.confidentialImpact == 'N'):
        cvss.confidentialImpact = "None"
    if(cvss.confidentialImpact == 'P'):
        cvss.confidentialImpact = "Partial"
    if(cvss.confidentialImpact == 'C'):
        cvss.confidentialImpact = "Complete"
    
    if(cvss.integrityImpact == 'N'):
        cvss.integrityImpact = "None"
    if(cvss.integrityImpact == 'P'):
        cvss.integrityImpact = "Partial"
    if(cvss.integrityImpact == 'C'):
        cvss.integrityImpact = "Complete"    
        
    if(cvss.avalibilityImpact == 'N'):
        cvss.avalibilityImpact = "None"
    if(cvss.avalibilityImpact == 'P'):
        cvss.avalibilityImpact = "Partial"
    if(cvss.avalibilityImpact == 'C'):
        cvss.avalibilityImpact = "Complete"    
    
    if(cvss.severity == 'H'):
        cvss.severity = "High"
    if(cvss.severity == 'M'):
        cvss.severity = "Medium"
    if(cvss.severity == 'L'):
        cvss.severity = "Low"
    return cvss
def display_meta(req):
    return render_to_response('add_vuln.html')
# Create your views here.

def index(req):
    return render_to_response('index.html' , {'user':req.user})

def vulnerabilityNVD(req):
    errors = []
    header = 'Vulnerabilities List:'
    try:
        sum1 = CVE.objects.count()
        pageInfo = pagination_vul(int(sum1), req)
        vulnerabilities = CVE.objects.order_by("-cve_id").all()[pageInfo.curIndex - 1:pageInfo.endIndex]
        if pageInfo.curIndex == 1:
            pageInfo.curIndex = 0
        for vuln in vulnerabilities:
            vuln.exploits = vuln.exploit_set.count()
        return render_to_response('vulnerabilityNVD.html', {\
                                                    'vulnerabilities':vulnerabilities, \
                                                    'user':req.user, \
                                                     'pageInfo':pageInfo, 'header':header})
    except Exception as err:
        errors.append(err)  
        return render_to_response('vulnerabilityNVD.html', {'errors': errors, 'header':header})
def vulnerabilityPatch(req):
    errors = []
    header = 'Vulnerabilities With Patch List:'
    try:
    # vulnerabilities with patch
        vulnerabilitiesWithPatch = []
        pageInfo = None
        pageInfo = pagination_vul(int(0), req)
        
        if INFO.objects.all():
            sum1 = INFO.objects.exclude(Q(diff_link='') | Q(diff_link=None) | Q(check_flag=False)).values('cve').distinct().count()
            pageInfo = pagination_vul(int(sum1), req)
            cves = INFO.objects.exclude(Q(diff_link='') | Q(diff_link=None) | Q(check_flag=False)).values('cve').distinct().order_by('-cve')[pageInfo.curIndex - 1:pageInfo.endIndex]
            if pageInfo.curIndex == 1:
                pageInfo.curIndex = 0
           
            for cve in cves:
                vuln = CVE.objects.get(cve_id=cve['cve'])
                vuln.exploits = vuln.exploit_set.count()
                vulnerabilitiesWithPatch.append(vuln)
        if pageInfo.curIndex == 1:
            pageInfo.curIndex = 0
        return render_to_response('vulnerabilityWithPatch.html', {\
                                                        'vulnerabilities':vulnerabilitiesWithPatch, \
                                                        'user':req.user, \
                                                         'pageInfo':pageInfo, 'header':header})
        
    except Exception as err:
        errors.append(err)
        return render_to_response('vulnerabilityWithPatch.html', {'errors': errors, 'header':header})

def vulnerabilityReuse(req):    
    errors = []
    try:
        sum1 = REUSE.objects.count()
        pageInfo = pagination_vul(int(sum1), req)
        reuses = REUSE.objects.all().order_by('-info_id')[pageInfo.curIndex - 1:pageInfo.endIndex]
        if pageInfo.curIndex == 1:
            pageInfo.curIndex = 0
        vulnerabilitiesWithReuse = []
        for reuse in reuses:
            if reuse.info_id.cve not in vulnerabilitiesWithReuse:
                vulnerabilitiesWithReuse.append(reuse.info_id.cve)
        for vuln in vulnerabilitiesWithReuse:
            vuln.exploits = vuln.exploit_set.count()
        return render_to_response('vulnerabilityWithReuse.html', {\
                                                    'vulnerabilities':vulnerabilitiesWithReuse, \
                                                    'user':req.user, \
                                                     'pageInfo':pageInfo})
    except Exception as err:
        errors.append(err)  
        return render_to_response('vulnerabilityWithReuse.html', {'errors': errors})
class Info:
    def __init__(self):
        self.cve = None
        self.software = None
        self.softwareVersion = None
        self.vuln_file = None
        self.vuln_func = None
        self.contain_version = None
        self.reuse_version = None
        self.diff_link = None
        self.diff_file = None
        
def importDiffBatch(req):
    errors = []
    try:
        if req.method == "POST":
            if 'excel' in req.FILES and 'diff_tar' in req.FILES:
                excel = req.FILES['excel']
                diff_tar = req.FILES['diff_tar']
                
        return render_to_response('importDiffBatch.html', {'errors': errors})
    except Exception as err:
        errors.append(err)    
        return render_to_response('importDiffBatch.html', {'errors': errors})
def importDiff(req):
    errors = []
    try:
        if req.method == "POST":
            print(req.POST)
            print(req.FILES)
            if 'cve' in req.POST:
                cveid = req.POST['cve']
                cve = CVE.objects.get(cve_id=cveid)
                if not cveid:
                    errors.append('CVE does not exists,please check')
                    return render_to_response('importDiff.html', RequestContext(req, {'errors': errors}))
                info = INFO()
                info.cve = cve
                if 'software' in req.POST:
                    software = req.POST['software']
                    info.software = software
                    info1s = INFO.objects.filter(software=software).filter(cve=cve)
                    for info1 in info1s:
                        if info1 and info1.check_flag == True:
                            errors.append('Info exists,please check')
                            return render_to_response('importDiff.html', RequestContext(req, {'errors': errors}))
                        if info1.check_flag == False:
                            info = info1
                if 'softwareVersion' in req.POST:
                    softwareVersion = req.POST['softwareVersion']
                    info.software_version = softwareVersion
                if 'vuln_file' in req.POST:
                    vuln_file = req.POST['vuln_file']
                    info.vuln_file = vuln_file
                if 'vuln_func' in req.POST:
                    vuln_func = req.POST['vuln_func']
                    info.vuln_func = vuln_func
                if 'contain_version' in req.POST:
                    contain_version = req.POST['contain_version']
                    info.contain_version = contain_version
                if 'reuse_version' in req.POST:
                    reuse_version = req.POST['reuse_version']
                    info.reuse_version = reuse_version    
                if 'diff_link' in req.POST:
                    diff_link = req.POST['diff_link']
                    info.diff_link = diff_link
                if 'diff_file' in req.FILES:
                    diff_file = req.FILES['diff_file']
                    diffPath = DIFFIMPORTNAME + info.software + '-diff' + '/';
                    filePath = handle_uploaded_file(diff_file, diffPath, cveid, True)
                    info.diff_file = filePath
                    print(filePath)
                if 'author' in req.POST:
                    info.author = req.POST['author']
                info.publish_date = datetime.now()
                info.check_flag = True
                info.save()
                errors.append('Import successfully')
                return render_to_response('importDiff.html', RequestContext(req, {'errors': errors}))   
        return render_to_response('importDiff.html', RequestContext(req, {'errors': errors}))
    except Exception as err:
        errors.append(err)
        print(errors)
        return render_to_response('importDiff.html', RequestContext(req, {'errors': errors}))

class UserForm(forms.Form):
    username = forms.CharField(max_length=20, label=u"username")
    password = forms.CharField(widget=forms.PasswordInput, max_length=20, label=u"password")
    
def login(req):
    if req.method == "POST":
        print(req.POST)
        user_form = UserForm(req.POST)
        if user_form.is_valid():
            username = user_form.cleaned_data['username']
            password = user_form.cleaned_data['password']
            user = auth.authenticate(username=username, password=password)
            if user:
                auth.login(req, user) 
                response = render_to_response("index.html", RequestContext(req))
                if 'next' in req.GET:
                        return HttpResponseRedirect(req.GET["next"])
                # 将username写入浏览器cookie,失效时间为3600
                return response
            else:
                wrong = 'wrong username or password'
                return render_to_response("login.html", RequestContext(req, {'wrong':wrong}))
        else:
            wrong = 'please input username and password'
            return render_to_response("login.html", RequestContext(req, {'wrong':wrong}))
    else:
        wrong = None
        if 'wrong' in req.GET:
            wrong = req.GET['wrong']
        return render_to_response("login.html", RequestContext(req, {'wrong':wrong}))

def logout(req):
    auth.logout(req)
    logout = "logout"
    return render_to_response("index.html", {'logout':logout}) 

class RegistrationForm(forms.Form):
    username = forms.CharField(label=u'username', max_length=100)
    password1 = forms.CharField(widget=forms.PasswordInput, max_length=20, label=u"password1")
    password2 = forms.CharField(widget=forms.PasswordInput, max_length=20, label=u"password2")
    email = forms.EmailField(label=u'email')
    
def registration(req):
    if req.method == "POST":
        uf = RegistrationForm(req.POST)
        if uf.is_valid():
            # get form
            username = uf.cleaned_data['username']
            password1 = uf.cleaned_data['password1']
            password2 = uf.cleaned_data['password2']
            email = uf.cleaned_data['email']
            errors = []
            if password1 != password2:
                errors.append("Entered passwords differ!")
                return render_to_response('registration.html', RequestContext(req, {'uf':uf, 'errors':errors})) 
            
            filterResult = User.objects.filter(username=username)  #c************  
            if len(filterResult) > 0:  
                errors.append("A username already exists")  
                return render_to_response('registration.html', RequestContext(req, {'uf':uf, 'errors':errors})) 
            # install to mysql
            # user = User.objects.create(username,email,password2)
            user = User.objects.create_user(username, email, password2)
            user.save()
            profile = PROFILE()
            profile.user = user
            profile.part = 1
            profile.credits = 0
            profile.save()
            # login
            # login_user=auth.authenticate(username=username, password=password1)
            # auth.login(req, login_user) 
            # 返回注册成功页面
            return render_to_response('success.html', RequestContext(req, {'tips':"Registration successful.Please login" + username}))
        else:
            errors.append("Please input username、password and email")
            return render_to_response('registration.html', RequestContext(req, {'uf':uf, 'errors':errors}))    
    else:
        uf = RegistrationForm()
        return render_to_response('registration.html', context_instance=RequestContext(req, {'uf':uf}))

def forum(req):
    return render_to_response('forum.html', {'user':req.user})

def detailVul(req):
    errors = []
    try:
        if 'q' in req.GET:
            q = req.GET['q']
            if not validCVE(q):
                errors.append('Enter a search term.')
            else:
                if not re.match('^CVE-', q):
                    q = 'CVE-' + q
            vulnerabilityDetail = getVulnerabilityDetail(q, req)
            if vulnerabilityDetail == None:
                errors.append("No Term Found")
                return render_to_response('detail_vul.html', {'errors': errors, 'query':q})
            return render_to_response('detail_vul.html', {'query':q, 'vulnerabilityDetail':vulnerabilityDetail})
        return render_to_response('detail_vul.html', {'errors': errors})
    except Exception as err:
        errors.append(err)
        return render_to_response('detail_vul.html', {'errors': errors})
    

def validCVE(cveid):
    patt = '^(CVE-)?[0-9]{4}-[0-9]{1,39}$'
    m = re.match(patt, cveid)
    if not m:
        return False
    return True

def searchCVE(req):
    errors = []
    query = []
    q = req.GET['q']
    if not q:
        errors.append('Enter a search term.')
    elif not validCVE(q):
        errors.append('Incorrect CVE ID, expected format: CVE-[0-9]{4}-[0-9]{1,39} or [0-9]{4}-[0-9]{1,39}')
    else:            
        query.append(q)
        try:
            vulnerabilities = CVE.objects.filter(cve_id__contains=q)
            for vuln in vulnerabilities:
                vuln.exploits = vuln.exploit_set.count()
            pageInfo = pagination_vul(len(vulnerabilities), req)
            return render_to_response('search_results.html', {'vulnerabilities':vulnerabilities, 'user':req.user, 'q':q, 'pageInfo':pageInfo})
        except:
            errors.append("ERROR")
    return render_to_response('search_results.html', {'errors': errors, 'q':q, 'user':req.user})      

def searchVul(req):
    if 'q' in req.GET:  # search 
        return searchCVE(req)
    elif 'ad_q' in req.GET:  # advanced search
        return searchAdvanced(req)
    # elif 'Analysis' in req.GET:  # analysis
    #    return analysis(req)
    else:
        return render_to_response('404.html') 

def searchAdvanced(req):
        errors = []
        query = []
        vulnerabilities = []
        cursor = connection.cursor()
        sql = "select distinct CVEID from vulnerability_cve"
        condition = None
        if 'ExploitsCheckBox' in req.GET:
            ExploitsCheck = req.GET['ExploitsCheckBox']
            if ExploitsCheck:
#                 if sql.find('vulnerability_exploit') == -1:
#                     sql = sql + ",vulnerability_exploit"
                temp = "CVEID in (select cve_id from vulnerability_exploit)"
                condition = add_condition(condition, temp)
                query.append('Contain exploits')
                
        if 'ReuseCheckBox' in req.GET:
            ReuseCheck = req.GET['ReuseCheckBox']
            if ReuseCheck:
                if sql.find('vulnerability_reuse') == -1:
                    sql = sql + ',vulnerability_reuse'
                if sql.find('vulnerability_info') == -1:
                    sql = sql + ',vulnerability_info'
                temp = 'CVEID=vulnerability_info.cve_id and vulnerability_reuse.info_id_id=vulnerability_info.id'
                condition = add_condition(condition, temp)
                query.append('Contain reuse code')
                
        if 'ReuseFeatureList' in req.GET:
            ReuseFeature = req.GET['ReuseFeatureList']
            if ReuseFeature:
                temp="CVEID in (select cve_id from vulnerability_info where id in (select info_id_id from vulnerability_reuse where id in (select reuse_id from vulnerability_reusefeature where feature_id='{0}')))".format(ReuseFeature)
                condition = add_condition(condition, temp)
                query.append('Reuse feature contain '+ReuseFeature)
                
#                 resuseFeatureFlag = 1
#                 feature = FEATURE.objects.get(id=ReuseFeature)
#                 resuseFeatures = REUSEFEATURE.objects.filter(feature=feature)
#                 for reuseFeature in resuseFeatures:
#                     if reuseFeature.reuse.info_id.cve not in resuseFeatureCves:
#                         resuseFeatureCves.append(reuseFeature.reuse.info_id.cve)
        if 'DiffCheckBox' in req.GET:
            DiffCheck = req.GET['DiffCheckBox']
            if DiffCheck:
                if sql.find('vulnerability_info') == -1:
                    sql = sql + ',vulnerability_info'
                temp = 'CVEID=vulnerability_info.cve_id'
                condition = add_condition(condition, temp)
                temp = "Diff_Link is not null"
                condition = add_condition(condition, temp)
                query.append('Contain diff')
        # CveIdentifier CveIdentifierTextBox
        CveIdentifier = req.GET['CveIdentifierTextBox']
        if CveIdentifier:
            if not validCVE(CveIdentifier):
                errors.append('Incorrect CVE ID, expected format: CVE-[0-9]{4}-[0-9]{1,39} or [0-9]{4}-[0-9]{1,39}')
            else:
                temp = "CVEID rlike '[CVE-]?" + CveIdentifier + "'" 
                condition = add_condition(condition, temp)
                query.append('CVEID:' + CveIdentifier)
        
        # Keyword QueryTextBox    
        keyword = req.GET['QueryTextBox']
        if keyword:
            if len(keyword) > 20:
                errors.append('Please submit keyword 20 characters or shorter')
            else:
                temp = "Description rlike '.*" + keyword + ".*'" 
                condition = add_condition(condition, temp)
                query.append('Description KeyWords:' + keyword)
                
        # cweid CweDropDownList    
        cweid = req.GET['CweDropDownList']
        if cweid != "":
            if (cweid == "CWE-noinfo") or (cweid == 'CWE-Other'):
                temp = "cweid is null"
            else:
                temp = "CWEID = '" + cweid + "'"
                query.append('CWEID:' + "Get the CWE Value from ID is not done .we have no cwe dictionary yet")
            condition = add_condition(condition, temp)
            
        # Vendor CPEVendorTextBox
#         vendor = req.GET['CPEVendorTextBox']
#         if vendor:
#             if len(vendor) > 20:
#                 errors.append('Please submit Vendor 20 characters or shorter')
#             else:  # if has cpe then use cpe sql
#                 sql = "select * from vulnerability_cve"
#                 temp = "company= '" + vendor + "'"
#                 condition = add_condition(condition, temp)
#                 query.append('Vendor:' + vendor)
        # Product CPEProductTextBox
#         product = req.GET['CPEProductTextBox']
#         if product:
#             if len(product) > 20:
#                 errors.append('Please submit Product 20 characters or shorter')
#             else:  # if has cpe then use cpe sql
#                 sql = "select * from vulnerability_cve"
#                 temp = "name rlike '.*" + product + ".*'"
#                 condition = add_condition(condition, temp)
#                 query.append('Product:' + product)
        # version CPEVersionTextBox
#         version = req.GET['CPEVersionTextBox']
#         if version:
#             if not product:
#                 errors.append('Version needs Product first')
#             elif len(version) > 20:
#                 errors.append('Please submit Version 20 characters or shorter')
#             else:
#                 sql = "select * from vulnerability_cve"
#                 temp = "SoftwareVersion = '" + version + "'"
#                 condition = add_condition(condition, temp)
#                 query.append('Version:' + version)
        # Modify date Range
        # startTime ModDateStartMonthDropDown ModDateStartYearDropDown
        flag = None
        month = req.GET['ModDateStartMonthDropDown']
        year = req.GET['ModDateStartYearDropDown']
        if month != "0" and year != "0":
            startTime = year + "-" + month.zfill(2) + "-01T00:00.000-00:00"
            temp = "update_date >= '" + startTime + "'"
            condition = add_condition(condition, temp)
            query.append('Modified Date Start Time:' + year + "-" + month.zfill(2))
        elif (month == '0' and year != '0') or (month != '0' and year == '0'):
            flag = 1
        # endTime  ModDateEndMonthDropDown ModDateEndYearDropDown
        month = req.GET['ModDateEndMonthDropDown']
        year = req.GET['ModDateEndYearDropDown']
        if month != "0" and year != "0":
            endTime = year + "-" + month.zfill(2) + "-31T23:59.999-23:59"
            temp = "update_date <= '" + endTime + "'"
            condition = add_condition(condition, temp)
            query.append('Modified Date End Time:' + year + "-" + month.zfill(2))
        elif (month == '0' and year != '0') or (month != '0' and year == '0'):
            flag = 1 
        if flag != None:
            errors.append('Any dates chosen must select both Month and Year')
        # CVSS 
        # CvssSevBaseDropDown
        res = req.GET['CvssSevBaseDropDown']
        if res != "":
            if res == "LOW":
                low = 0
                high = 3
            elif res == "MEDIUM":
                low = 4
                high = 6
            elif res == "MEDIUM_HIGH":
                low = 4
                high = 10
            elif res == "HIGH":
                low = 7
                high = 10
            temp = "CVSS >= '%s' and CVSS <= '%s'" % (low, high)
            condition = add_condition(condition, temp)
            query.append('Severity (Base Score Range):' + str(res))
            # CvssAvDropDown
        
        res = req.GET['CvssAvDropDown']
        temp = ""
        if res != "":
            if res == "LOCAL":
                temp = "accessVector='L'"
            elif res == "LOCAL_NETWORK":
                temp = "accessVector='A'"
            elif res == "NETWORK":
                temp = "accessVector='N'"
            if len(temp) > 0:
                if sql.find('vulnerability_cvss') == -1:
                    sql = sql + ',vulnerability_cvss'
                condition = add_condition(condition, temp)
                temp = 'vulnerability_cvss.cveid_id=CVEID'
                condition = add_condition(condition, temp)
                query.append('CVSS (Access Vector):' + str(res))
        if errors:
            return render_to_response('search_advanced.html', {'errors': errors})
        if condition:
            sql = sql + " where " + condition + " order by CVEID DESC"
        try:
            sql += ";"
            print(sql)
            cursor.execute(sql)
            # get data
            desc = cursor.description
            rows = [ dict(zip([col[0] for col in desc], row)) for row in cursor.fetchall()]
            sum1 = len(rows)
            pageInfo = pagination_vul(int(sum1), req)
            rows1 = rows[pageInfo.curIndex - 1:pageInfo.endIndex]
            if pageInfo.curIndex == 1:
                pageInfo.curIndex = 0
            for row in rows1:
                cveid = row['CVEID']
                vulnTemp = CVE.objects.get(cve_id=cveid)   
                vulnTemp.exploits = vulnTemp.exploit_set.count()
                vulnerabilities.append(vulnTemp)
            return render_to_response('search_results.html',
                {'vulnerabilities':vulnerabilities, 'query':query, 'pageInfo':pageInfo})
        except Exception as err:
            print(err)
            errors.append(err)
        finally:
            cursor.close()
        return render_to_response('searchAdvanced.html', {'errors': errors, 'query':query})
def search_advanced(req):
    # show query page 
    features = FEATURE.objects.all()
    return render_to_response('searchAdvanced.html', {'features':features})
def add_condition(condition, str1):
    if condition:
        if condition.find(str1) == -1: 
            str1 = " and " + str1 
            condition += str1
    else:
        condition = str1
    return condition

def add_Save(req):
    curtime = datetime.now()
    errors = []
    if req.method == 'GET':  
        print("GET")  
        cve_id = req.GET['cve_id']
        cwe_id = req.GET['cwe_id']
        vuln_type = req.GET['vuln_type']
        cvss_id = req.GET['cvss_id']
        description = req.GET['description']
        user = req.GET['user']
        cveResult = CVE.objects.filter(cve_id=cve_id)
        if len(cveResult) > 0:
            errors.append("cve exists")
            return render_to_response('add_success.html', {'errors':errors})
        cve = CVE()
        cve.cve_id = cve_id
        cve.cwe_id = cwe_id
        cve.vuln_type = vuln_type
        cve.cvss_id = cvss_id
        cve.description = description
        cve.user = user
        cve.update_date = curtime
        cve.save()
    return render_to_response('add_success.html', {'errors':errors})

def pagination_vul(sum1, request):
    errors = []
    pageInfo = PageIndex()
    try:
        # page index info
        pageInfo.sum = sum1
        if sum1 % PAGENUMS == 0:
            pageInfo.endPageNum = int(sum1 / PAGENUMS)
        else:
            pageInfo.endPageNum = int(sum1 / PAGENUMS) + 1
        # query string  
        if 'QUERY_STRING' in request.META:
            queryString = request.META['QUERY_STRING']
            re.sub('&startIndex.*$', '', queryString)
            pageInfo.queryString = queryString
        startIndex = 0
        if 'startIndex' in request.GET:
            startIndex = int(request.GET['startIndex'])
          ###########take care of request
        pageInfo.curIndex = startIndex + 1  # page index start from 1,so it needs +1 there  
        pageInfo.endIndex = pageInfo.getEndIndex()
        if sum1 > PAGENUMS:
            pageInfo.lastPageIndex = sum1 - sum1 % PAGENUMS
        else:
            pageInfo.lastPageIndex = 0
        # page num info
        firstPageNum = 1
        if 'firstPageNum' in request.GET:
            firstPageNum = int(request.GET['firstPageNum'])
        # if request.session.get('firstpagenum'):
            # firstPageNum = request.session['firstpagenum']
        # else:
            # request.session['firstpagenum'] = firstPageNum
        lastPageNum = firstPageNum + 9
        if lastPageNum > pageInfo.endPageNum:
            lastPageNum = pageInfo.endPageNum
        pageInfo.curPageNum = int(startIndex / PAGENUMS) + 1
        pageInfo.pages = range(firstPageNum, lastPageNum + 1)
        if pageInfo.curPageNum == lastPageNum:  # and pageInfo.curPageNum != pageInfo.endPageNum:#the last pageNum adjust nav bar
            lastPageNum = pageInfo.curPageNum + 5 
            if lastPageNum > pageInfo.endPageNum:
                lastPageNum = pageInfo.endPageNum
            firstPageNum = lastPageNum - 9
            if firstPageNum < 1:
                firstPageNum = 1
        elif pageInfo.curPageNum == firstPageNum and pageInfo.curPageNum != 1:  # and pageInfo.curPageNum != 1:
            firstPageNum = pageInfo.curPageNum - 5
            if firstPageNum < 1:
                firstPageNum = 1
            lastPageNum = firstPageNum + 9
        elif pageInfo.curPageNum == 1:
            firstPageNum = 1
            lastPageNum = 10
            if lastPageNum > pageInfo.endPageNum:
                lastPageNum = pageInfo.endPageNum
        elif pageInfo.curPageNum == pageInfo.endPageNum:
            lastPageNum = pageInfo.endPageNum
            firstPageNum = pageInfo.curPageNum - 9
            if firstPageNum < 1:
                firstPageNum = 1
        pageInfo.page = firstPageNum
        pageInfo.pages = range(firstPageNum, lastPageNum + 1)
        pageInfo.firstPageNum = firstPageNum
        print(pageInfo.pages)
        return pageInfo        
    except Exception as e:
        errors.append(e)
        print(errors)
        return pageInfo
        
def rewardCVEadd(req):
    if '_save' in req.GET: 
        return add_Save(req)
    else:
        return render_to_response('add_vuln.html')
     
def editVulnerability(req):
    if 'q' in req.GET:
        q = req.GET['q']
        vulnerability = CVE.objects.get(cve_id=q)
        return render_to_response('edit_vuln.html', {'vulnerability':vulnerability})
    elif '_update' in req.GET:
        cve_id = req.GET['cve_id']
        vulnerability = CVE.objects.get(cve_id=cve_id)
        vulnerability.cve_id = req.GET['cve_id']
        vulnerability.cwe_id = req.GET['cwe_id']
        vulnerability.vuln_type = req.GET['vuln_type']
        vulnerability.cvss_id = req.GET['cvss_id']
        vulnerability.description = req.GET['description']
        vulnerability.user = req.GET['user']
        vulnerability.save()
        return render_to_response("success.html")
    else:
        return render_to_response('edit_vuln.html')
class DiffFeature():
    def __init__(self):
        self.num = None
        self.feature = []
def search_file(file_name, search_path, pathsep=os.pathsep): 
    for path in search_path.split(pathsep): 
        candidate = os.path.join(path, file_name) 
        if os.path.isfile(candidate): 
            return os.path.abspath(candidate) 
    return None
def diffInfoShow(req):
    errors = []
    difftxt = None
    diffInfo = None
    try:
        if 'info' in req.GET:
            info = req.GET['info']
        diffInfo = INFO.objects.get(id=int(info))
        diffInfoList = []
        if diffInfo.diff_link:
            diffInfoList = INFO.objects.filter(diff_link=diffInfo.diff_link)
        filename = None
        if not os.path.exists(diffInfo.diff_file):
            filename = 'diffs/' + diffInfo.diff_file
        if filename:
            diffInfo.diff_file = filename
            diffInfo.save()
        with open(diffInfo.diff_file) as f:
            difftxt = f.read()
        # handle features
        diffFeatures = getDiffFeatures(diffInfo)
        return render_to_response('diffInfo.html', {'errors': errors, 'info':diffInfo, 'difftxt':difftxt, 'diffList':diffInfoList, 'diffFeatures':diffFeatures})
    except Exception as err:
        errors.append(err)
        return render_to_response('diffInfo.html', {'errors': errors})
    
def getDiffFeatures(info):
    str_sql = "select distinct number from vulnerability_difffeature where info_id_id=" + str(info.id)
    print(str_sql)
    rows = my_custom_sql(str_sql)
    print(rows)
    diffFeatures = []
    for row in rows:
        diffFeature = DiffFeature()
        diffFeature.num = row['number']
        print(diffFeature.num)
        diffFeature.feature = DIFFFEATURE.objects.filter(info_id=info, number=diffFeature.num)
        print(diffFeature.feature)
        diffFeatures.append(diffFeature)
    return diffFeatures

def my_custom_sql(str_sql):
    cursor = connection.cursor()
    cursor.execute(str_sql)
    desc = cursor.description
    rows = [ dict(zip([col[0] for col in desc], row)) for row in cursor.fetchall()]
    return rows
def download(req):
    from django.http import StreamingHttpResponse
    errors = []
    try:
        def file_iterator(file_name, chunk_size=512):
            with open(file_name) as f:
                while True:
                    c = f.read(chunk_size)
                    if c:
                        yield c
                    else:
                        break
        if 'file' in req.GET:
            filename = req.GET['file']
            m = filename.split('\\')
            response = StreamingHttpResponse(file_iterator(filename))
            response['Content-Type'] = 'application/octet-stream'
            str1 = 'attachment;filename="diff_' + m[-1] + '"'
            response['Content-Disposition'] = str1.format(filename)
            return response
        
        if 'info'in req.GET:
            infoid = req.GET['info']
            func = req.GET['func']
            version = req.GET['version']
            info = INFO.objects.get(id=infoid)
            reuse = REUSE.objects.get(info_id=info, version=version, patch_func=func)
            response = StreamingHttpResponse(reuse.code)
            response['Content-Type'] = 'application/octet-stream'
            str1 = 'attachment;filename="' + info.cve.cve_id + '_' + reuse.patch_func + '.txt"'
            response['Content-Disposition'] = str1.format()
            return response
    except Exception as err:
        errors.append(err)
        return HttpResponse("Download failed!")  
def featureShow(req):
    errors = []
    try:
        features = FEATURE.objects.all()
        return render_to_response('aboutFeature.html', {'features':features})
    except Exception as err:
        errors.append(err)
        return render_to_response('aboutFeature.html', {'errors':errors})
def rewardIndex(req):
    if req.user.is_superuser:
        print('is super')
    return render_to_response('rewardIndex.html', {'user':req.user})
def rewardIncompleteListDiff(req):
    from django.db.models import Q
    errors = []
    try:
        sum1 = INFO.objects.filter(Q(diff_link='') | Q(diff_file='')).count()
        
        infos = []
        infosTemp = INFO.objects.filter(Q(diff_link='') | Q(diff_file=''))
        for info in infosTemp:
            reward = REWARDDIFF.objects.filter(info_id=info)
            if reward:
                sum1 -= 1
                continue
            infos.append(info)
        pageInfo = pagination_vul(int(sum1), req)
        return render_to_response('rewardIncompleteListDiff.html', {'user':req.user, 'errors':errors, 'infos':infos, 'pageInfo':pageInfo})
    except Exception as err:
        errors.append(err)    
        return render_to_response('rewardIncompleteListDiff.html', {'user':req.user, 'errors':errors})
def rewardDiffAddToList(req):
    errors = []
    try:
        if '_toReward' in req.GET: 
            infoId = req.GET['infoId']
            title = req.GET['title']
            credit = req.GET['CreditList']
            rewardDiff = REWARDDIFF()
            info = INFO.objects.get(id=infoId)
            rewardDiff.info_id = info
            rewardDiff.title = title
            rewardDiff.publish_date = datetime.now()
            rewardDiff.credits = CREDIT.objects.get(creditRank=credit)
            rewardDiff.save()
            errors.append("succeed")
            return render_to_response('rewardIncompleteListDiff.html', {'errors':errors, 'user':req.user})
        else:
            if 'infoId' in req.GET:
                infoId = req.GET['infoId']
                info = INFO.objects.get(id=infoId)
                print(info)
            creditlist = CREDIT.objects.all()
            if info.diff_file and len(info.diff_file) > 0:
                with open(info.diff_file) as f:
                    difftxt = f.read()
                info.diff_file = difftxt
            return render_to_response('rewardDiffAddToList.html', {'errors':errors, 'user':req.user, 'info':info, 'credits':creditlist})
    except Exception as err:
        errors.append(err) 
        return render_to_response('rewardDiffAddToList.html', {'errors':errors, 'user':req.user})
class RewardDiff():
    def __init__(self):
        self.rewarddiff = REWARDDIFF
        self.submit = None
        
def rewardDiffList(req):
    errors = []
    try:
        rewardDiffs = []
        rewarddiffs = REWARDDIFF.objects.all()
        for reward in rewarddiffs:
            rewarddiff = RewardDiff()
            rewarddiff.rewarddiff = reward
            rewarddiff.submit = DIFFSUBMIT.objects.filter(rewardDiff=reward).count()
            if rewarddiff.rewarddiff.info_id.check_flag == True:
                continue
            rewardDiffs.append(rewarddiff)
        return render_to_response('rewardDiff.html', {'user':req.user, 'errors':errors, 'rewarddiffs':rewardDiffs})
    except Exception as err:
        errors.append(err)     
        return render_to_response('rewardDiff.html', {'user':req.user, 'errors':errors})
    
def handle_uploaded_file(f, filename, username, isImport=False):
    f_path = filename
    if not os.path.exists(f_path):
        os.makedirs(f_path)
    if isImport:
        f_path = f_path + username + '.txt'
    else:
        f_path = f_path + datetime.now().strftime('%Y%m%d%H%M%S') + username + '.txt'
    with open(f_path, 'wb+') as info: 
        for chunk in f.chunks(): 
            info.write(chunk) 
    return f_path
    
def rewardDiffAdd(req):
    errors = []
    if not req.user.is_authenticated():
        wrong = 'Please login first befor submitting!'
        return render_to_response("login.html", RequestContext(req, {'wrong':wrong}))
    try:
        if req.method == 'POST':
            diffLink = req.POST['diffLink']
            
            title = req.GET['rewardDiff']
            rewarddiff = REWARDDIFF.objects.get(title=title)
            
            f = req.FILES['difffile']
            filePath = handle_uploaded_file(f, DIFFFILENAME, req.user.username)
            
            diffSubmit = DIFFSUBMIT()
            diffSubmit.diff_link = diffLink
            diffSubmit.diff_file = filePath
            diffSubmit.user = req.user.username
            diffSubmit.rewardDiff = rewarddiff
            diffSubmit.submit_date = datetime.now()
            diffSubmit.save()
            errors.append("Add diff succssfully!")
            return render_to_response('rewardDiffAdd.html', RequestContext(req, {'user':req.user, 'errors':errors}))
        else:
            if 'rewardDiff' in req.GET:
                title = req.GET['rewardDiff']
                rewarddiff = REWARDDIFF.objects.get(title=title)
                return render_to_response('rewardDiffAdd.html', RequestContext(req, {'user':req.user, 'errors':errors, 'rewarddiff':rewarddiff})) 
        return render_to_response('rewardDiffAdd.html', RequestContext(req, {'user':req.user, 'errors':errors}))
    except Exception as err:
        errors.append(err)     
        return render_to_response('rewardDiffAdd.html', {'user':req.user, 'errors':errors})    
def rewardIncompleteListExploits(req, errors=None):
    errors = errors
    vulnList = []
    if not req.user.is_superuser:
        errors.append("You hava no rigths~~~")
        return render_to_response('rewardIncompleteListExploits.html', RequestContext(req, {'errors':errors}))
    try:
        cursor = connection.cursor()
        sql='select * from vulnerability_cve where CVEID not in (select cve_id from vulnerability_exploit) and CVEID not in(select cve_id_id from vulnerability_rewardexploit) order by CVEID DESC'
        cursor.execute(sql)
        # get data
        desc = cursor.description
        rows = [ dict(zip([col[0] for col in desc], row)) for row in cursor.fetchall()]
        sum1 = len(rows)
        pageInfo = pagination_vul(int(sum1), req)
        rows1 = rows[pageInfo.curIndex - 1:pageInfo.endIndex]
        if pageInfo.curIndex == 1:
            pageInfo.curIndex = 0
        for row in rows1:
            cveid = row['CVEID']
            vulnTemp = CVE.objects.get(cve_id=cveid)   
            vulnTemp.exploits = vulnTemp.exploit_set.count()
            vulnList.append(vulnTemp)
        return render_to_response('rewardIncompleteListExploits.html', RequestContext(req, {'errors':errors, 'vulnerabilities':vulnList, 'pageInfo':pageInfo}))
    except Exception as err:
        errors.append(err) 
        return render_to_response('rewardIncompleteListExploits.html', RequestContext(req, {'errors':errors}))
    finally:
        cursor.close()
def rewardExploitsAddToList(req):
    errors = []
    if not req.user.is_superuser():
        errors.append("You hava no rigths~~~")
        return render_to_response('rewardExploitsAddToList.html', RequestContext(req, {'errors':errors}))
    try:
        if '_toReward' in req.GET: 
            cveid = req.GET['cveid']
            cve = CVE.objects.get(cve_id=cveid)
            credit = req.GET['CreditList']
            rewardExploit = REWARDEXPLOIT()
            rewardExploit.cve_id = cve
            rewardExploit.credits = CREDIT.objects.get(creditRank=credit)
            rewardExploit = datetime.now()
            
            errors.append("succeed add " + cveid + " to reward")
            return HttpResponse("succeed add " + cveid + " to reward")
        else:
            if 'cveid' in req.GET:
                cveid = req.GET['cveid']
                cve = CVE.objects.get(cve_id=cveid)
                creditlist = CREDIT.objects.all()
            return render_to_response('rewardExploitsAddToList.html', RequestContext(req, {'errors':errors, 'user':req.user, 'cve':cve, 'credits':creditlist}))
    except Exception as err:
        errors.append(err)
        return render_to_response('rewardExploitsAddToList.html', RequestContext(req, {'errors':errors, 'user':req.user}))
class RewardExploit():
    def __init__(self):
        self.rewardexloit = REWARDEXPLOIT
        self.submit = None
def rewardExploitsList(req):
    errors = []
    try:
        rewardExploits = REWARDEXPLOIT.objects.all()
#         exploits = EXPLOIT.objects.all()
#         for exploit in exploits:
#             exploit.check_flag = True
#             exploit.save()
        rewardexploits = []
        for rewardExploit in rewardExploits:
            rewardexploit = RewardExploit()
            rewardexploit.rewardexloit = rewardExploit
            rewardexploit.submit = EXPLOITSUBMIT.objects.filter(rewardExploit=rewardExploit).count()
            rewardexploits.append(rewardexploit)
        return render_to_response('rewardExploits.html', {'user':req.user, 'errors':errors, 'rewardExploits':rewardexploits})
    except Exception as err:
        errors.append(err) 
        return render_to_response('rewardExploits.html', {'user':req.user, 'errors':errors})

def rewardExploitsAdd(req):   
    errors = []
    try:
        if not req.user.is_authenticated():
            wrong = 'Please login first befor submitting!'
            return HttpResponseRedirect('/login/?wrong=' + wrong)
        if req.method == 'POST':
            exploitLink = req.POST['exploitLink']
            print(req.POST)
            id1 = req.GET['rewardExploit']
            rewardExploit = REWARDEXPLOIT.objects.get(id=id1)
#             code=req.GET['exploitCode']
            exploitSubmit = EXPLOITSUBMIT()
            exploitSubmit.rewardExploit = rewardExploit
            exploitSubmit.link = exploitLink
            exploitSubmit.user = req.user.username
            exploitSubmit.submit_date = datetime.now()
            exploitSubmit.save()
            return HttpResponse("Add exploit succssfully!")
        else:
            if 'rewardExploit' in req.GET:
                id1 = req.GET['rewardExploit']
                rewardexploit = REWARDEXPLOIT.objects.get(id=id1)
                return render_to_response('rewardExploitAdd.html', RequestContext(req, {'user':req.user, 'errors':errors, 'rewardexploit':rewardexploit})) 
        return render_to_response('rewardExploitAdd.html', RequestContext(req, {'user':req.user, 'errors':errors}))
    except Exception as err:
        errors.append(err)     
        return render_to_response('rewardExploitAdd.html', {'user':req.user, 'errors':errors})  

def rewardCheckList(req):
    
    return render_to_response('rewardIncompleteListCheck.html')
def rewardDiffCheckList(req):
    errors = []
    try:
        diffSubmits = DIFFSUBMIT.objects.filter(checkFlag=False)
        return render_to_response('rewardDiffCheckList.html', {'errors':errors, 'user':req.user, 'diffSubmits':diffSubmits})
    except Exception as err:
        errors.append(err)     
        return render_to_response('rewardDiffCheckList.html', {'errors':errors, 'user':req.user})
def rewardExploitCheckList(req):
    errors = []
    try:
        exploitSubmits = EXPLOITSUBMIT.objects.filter(checkFlag=False)
        return render_to_response('rewardExploitCheckList.html', {'errors':errors, 'user':req.user, 'exploitSubmits':exploitSubmits})
    except Exception as err:
        errors.append(err)
        return render_to_response('rewardExploitCheckList.html', {'errors':errors})
    
def rewardInfoCheckList(req):
    return render_to_response('rewardInfoCheckList.html')
def diffCheck(req):
    errors = []
    difftxt = None
    try:
        if req.method == 'POST':
            diffsubmitId = req.GET['diffSubmitId']
            diffsubmit = DIFFSUBMIT.objects.get(id=diffsubmitId)
            if '_pass' in req.POST:
                diffsubmit.passFlag = True
                diffsubmit.checkFlag = True
                diffsubmit.save()
                info = INFO.objects.get(id=diffsubmit.rewardDiff.info_id)
                info.diff_link = diffsubmit.diff_link
                info.diff_file = diffsubmit.diff_file
                info.check_flag = True
                info.save()
                user = User.objects.get(username=diffsubmit.user)
                profile = PROFILE.objects.get(user=user)
                profile.credits = profile.credits + diffsubmit.rewardDiff.credits.credits
                profile.save()
            if '_ignore' in req.POST:
                diffsubmit.passFlag = False
                diffsubmit.checkFlag = True
                diffsubmit.save()
            diffSubmits = DIFFSUBMIT.objects.filter(checkFlag=False)
            return render_to_response('rewardDiffCheckList.html', RequestContext(req, {'errors':errors, 'user':req.user, 'diffSubmits':diffSubmits}))
        elif 'diffSubmitId' in req.GET:
            diffsubmitId = req.GET['diffSubmitId']
            diffsubmit = DIFFSUBMIT.objects.get(id=diffsubmitId)
            with open(diffsubmit.diff_file) as f:
                difftxt = f.read()
            return render_to_response('rewardDiffCheckDetail.html', RequestContext(req, {'diffsubmit':diffsubmit, 'user':req.user, 'difftxt':difftxt}))
    except Exception as err:
        errors.append(err)      
        return render_to_response('rewardDiffCheckDetail.html', RequestContext(req, {'errors':errors, 'user':req.user}))
def exploitCheck(req):
    errors = []
    try:
        if req.method == 'POST':
            exploitsubmitId = req.GET['exploitSubmitId']
            exploitsubmit = EXPLOITSUBMIT.objects.get(id=exploitsubmitId)
            if '_pass' in req.POST:
                exploitsubmit.passFlag = True
                exploitsubmit.checkFlag = True
                exploitsubmit.save()
                cve = CVE.objects.get(cve_id=exploitsubmit.rewardExploit.cve_id)
                exploit = EXPLOIT()
                exploit.author = exploitsubmit.user
                exploit.link = exploitsubmit.link
                exploit.edb_id = 0
                exploit.cve = cve
                exploit.publish_date = datetime.now()
                exploit.check_flag = True
                exploit.save()
                user = User.objects.get(username=exploitsubmit.user)
                profile = PROFILE.objects.get(user=user)
                profile.credits += exploitsubmit.rewardExploit.credits.credits
                profile.save()
            if '_ignore' in req.POST:
                exploitsubmit.passFlag = False
                exploitsubmit.checkFlag = True
                exploitsubmit.save()
            exploitSubmits = EXPLOITSUBMIT.objects.filter(checkFlag=False)
            return render_to_response('rewardExploitCheckList.html', RequestContext(req, {'errors':errors, 'user':req.user, 'exploitSubmits':exploitSubmits}))
        elif 'exploitSubmitId' in req.GET:
            exploitsubmitId = req.GET['exploitSubmitId']
            exploitsubmit = EXPLOITSUBMIT.objects.get(id=exploitsubmitId)
            return render_to_response('rewardExploitCheckDetail.html', RequestContext(req, {'exploitsubmit':exploitsubmit, 'user':req.user}))
    except Exception as err:
        errors.append(err)      
        return render_to_response('rewardExploitCheckDetail.html', RequestContext(req, {'errors':errors}))
def infoCheck(req):
    return render_to_response('rewardInfoCheckDetail.html', RequestContext(req))
def userInfomation(req):
    errors = []
    try:
        if 'username' in req.GET:
            username = req.GET['username']
            user = User.objects.get(username=username)
            profile = PROFILE.objects.get(user=user)
            role = ""
            if profile.part == 0:
                role = 'Administrator'
            elif profile.part == 1:
                role = 'Normal user'
            return render_to_response('userInfomation.html', RequestContext(req, {'errors':errors, 'profile':profile, 'role':role}))
        return render_to_response('userInfomation.html', RequestContext(req, {'errors':errors}))                              
    except Exception as err:
        errors.append(err)
        return render_to_response('userInfomation.html', RequestContext(req, {'errors':errors}))
    
def rewardIncompleteListCVE(req):
    from django.db.models import Q
    errors = []
    try:
        sum1 = CVE.objects.filter(Q(description='') | Q(cvss_id=-1.0) | Q(cwe_id='None')).count()
        print(sum1)
        pageInfo = pagination_vul(int(sum1), req)
        cves = CVE.objects.filter(Q(description='') | Q(cvss_id=-1.0) | Q(cwe_id='None')).order_by("-cve_id")[pageInfo.curIndex - 1:pageInfo.endIndex]
        if pageInfo.curIndex == 1:
            pageInfo.curIndex = 0
        for cve in cves:
            cve.exploits = cve.exploit_set.count()
        return render_to_response('rewardIncompleteListCVE.html', {'pageInfo':pageInfo, 'user':req.user, 'errors':errors, 'cves':cves})
    except Exception as err:
        errors.append(err)    
        return render_to_response('rewardIncompleteListCVE.html', {'user':req.user, 'errors':errors, 'pageInfo':pageInfo})
def rewardCVEAddToList(req):
    errors = []
    try:
        if req.method == 'POST':
            print(req.POST)
            print(req.GET)
            if '_toReward' in req.POST:
                cveid = req.GET['cveid']
                cve = CVE.objects.get(cve_id=cveid)
                credit = req.POST['CreditList']
                rewardCVE = REWARDCVE()
                rewardCVE.credits = CREDIT.objects.get(creditRank=credit)
                rewardCVE.cve_id = cve
                rewardCVE.publish_date = datetime.now()
                rewardCVE.save()
                errors.append("succeed add " + cveid + " to reward")
                return render_to_response('rewardCVEAddToList.html', RequestContext(req, {'errors':errors, 'user':req.user}))
        else:
            if 'cveid' in req.GET:
                cveid = req.GET['cveid']
                cve = CVE.objects.get(cve_id=cveid)
                creditlist = CREDIT.objects.all()
            return render_to_response('rewardCVEAddToList.html', RequestContext(req, {'errors':errors, 'user':req.user, 'cve':cve, 'credits':creditlist}))
    except Exception as err:
        errors.append(err)
        return render_to_response('rewardCVEAddToList.html', RequestContext(req, {'errors':errors, 'user':req.user}))
class RewardCVE():
    def __init__(self):
        self.rewardCVE = REWARDCVE
        self.submit = None
def rewardCVEList(req):
    errors = []
    try:
        cves = REWARDCVE.objects.filter(passFlag=False)
        rewardCVEs = []
        for cve in cves:
            rewardCVE = RewardCVE()
            rewardCVE.rewardCVE = cve
            rewardCVE.submit = CVESUBMIT.objects.filter(rewardCVE=cve).count()
            rewardCVEs.append(rewardCVE)
        return render_to_response('rewardCVE.html', {'user':req.user, 'errors':errors, 'rewardCVEs':rewardCVEs})
    except Exception as err:
        errors.append(err) 
        return render_to_response('rewardCVE.html', {'user':req.user, 'errors':errors})
def rewardCVEAdd(req):   
    errors = []
    try:
        if not req.user.is_authenticated():
            wrong = 'Please login first befor submitting!'
            return HttpResponseRedirect('/login/?wrong=' + wrong)
        if req.method == 'POST':
            id1 = req.GET['rewardCVE']
            rewardcve = REWARDCVE.objects.get(id=id1)
            if not ('cvss_id' in req.POST or 'cwe_id' in req.POST or 'description' in req.POST):
                errors.append('Please input CWE or CVSS Severity or Summary information !')
                return render_to_response('rewardCVEAdd.html', {'user':req.user, 'errors':errors, 'rewardcve':rewardcve})
            
#             code=req.GET['exploitCode']
            cveSubmit = CVESUBMIT()
            cveSubmit.rewardCVE = rewardcve
            
            if 'cvss_id' in req.POST:
                cvess_id = req.POST['cvss_id']
                cveSubmit.cvss_id = cvess_id
                
            if 'description' in req.POST:
                description = req.POST['description']
                cveSubmit.description = description
            
            if 'cwe_id' in req.POST:
                cwe_id = req.POST['cwe_id']
                cveSubmit.cwe_id = cwe_id
            cveSubmit.user = req.user.username
            cveSubmit.submit_date = datetime.now()
            cveSubmit.save()
            errors.append("Add CVE succssfully!")
            return render_to_response('rewardCVEAdd.html', RequestContext(req, {'user':req.user, 'errors':errors})) 
        else:
            if 'rewardCVE' in req.GET:
                id1 = req.GET['rewardCVE']
                rewardcve = REWARDCVE.objects.get(id=id1)
                return render_to_response('rewardCVEAdd.html', RequestContext(req, {'user':req.user, 'errors':errors, 'rewardcve':rewardcve})) 
        return render_to_response('rewardCVEAdd.html', RequestContext(req, {'user':req.user, 'errors':errors}))
    except Exception as err:
        errors.append(err)     
        return render_to_response('rewardCVEAdd.html', {'user':req.user, 'errors':errors})  

def rewardCVECheckList(req):
    errors = []
    try:
        cveSubmits = CVESUBMIT.objects.filter(checkFlag=False)
        return render_to_response('rewardCVECheckList.html', {'errors':errors, 'user':req.user, 'cveSubmits':cveSubmits})
    except Exception as err:
        errors.append(err)
        return render_to_response('rewardCVECheckList.html', {'errors':errors})        
def CVECheck(req):
    errors = []
    try:
        if req.method == 'POST':
            cvesubmitId = req.GET['cveSubmitId']
            cvesubmit = CVESUBMIT.objects.get(id=cvesubmitId)
            if '_pass' in req.POST:
                cvesubmit.passFlag = True
                cvesubmit.checkFlag = True
                cvesubmit.rewardCVE.passFlag = True
                cvesubmit.rewardCVE.save()
                cvesubmit.save()
                cve = CVE.objects.get(cve_id=cvesubmit.rewardCVE.cve_id.cve_id)
                if cvesubmit.cwe_id:
                    cve.cwe_id = cvesubmit.cwe_id
                if cvesubmit.cvss_id:
                    cve.cvss_id = cvesubmit.cvss_id
                if cvesubmit.description:
                    cve.description = cvesubmit.description
                cve.update_date = datetime.now()
                cve.save()
                user = User.objects.get(username=cvesubmit.user)
                profile = PROFILE.objects.get(user=user)
                profile.credits += cvesubmit.rewardCVE.credits.credits
                profile.save()
            if '_ignore' in req.POST:
                cvesubmit.passFlag = False
                cvesubmit.checkFlag = True
                cvesubmit.save()
            cveSubmits = CVESUBMIT.objects.filter(checkFlag=False)
            return render_to_response('rewardCVECheckList.html', {'errors':errors, 'user':req.user, 'cveSubmits':cveSubmits})
        elif 'cveSubmitId' in req.GET:
            cvesubmitId = req.GET['cveSubmitId']
            cvesubmit = CVESUBMIT.objects.get(id=cvesubmitId)
        return render_to_response('rewardCVECheckDetail.html', RequestContext(req, {'cvesubmit':cvesubmit, 'user':req.user}))
    except Exception as err:
        errors.append(err)      
        return render_to_response('rewardCVECheckDetail.html', RequestContext(req, {'errors':errors})) 
    
