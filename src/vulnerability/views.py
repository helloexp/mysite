from django.shortcuts import render_to_response
from django.contrib import auth
from django.http import HttpResponse, HttpResponseRedirect
from vulnerability.models import CVE, REUSE, CVSS, EXPLOIT, INFO, FUNC, FEATURE, REUSEFEATURE, DIFFFEATURE
from vulnerability.models import CREDIT, REWARDDIFF, DIFFSUBMIT
from vulnerability.models import EXPLOITSUBMIT,REWARDEXPLOIT
from django import forms
# from vulnerability.models import RegisterForm
from django.template import RequestContext
from django.db import connection
import re
import os
from _datetime import datetime
PAGENUMS = 20
DIFFFILENAME = 'difffile/'

class PageIndex:
    def __init__(self):
        self.sum = 0
        self.curIndex = 0
        self.endIndex = 0
        self.lastPageIndex = 0
        self.firstPageNum = 1
        self.curPageNum = 1
        self.endPageNum = 1
        self.pages = range(self.curPageNum, self.curPageNum + 10)
        self.page = 1  # only for pages
        self.queryString = None
    def getPageIndex(self):  # from pages Num to Index
        index = (self.page - 1) * PAGENUMS
        self.page += 1
        return index
    def getEndIndex(self):
        endIndex = int(self.curIndex) + PAGENUMS - 1
        if endIndex > self.sum:
            return self.sum
        else:
            return endIndex
class VulnerabilityDetail:
    def __init__(self):
        self.CVE = CVE
        self.CVSS = CVSS
        self.INFO = []
        self.EXPLOITS = []
        self.REUSES = []
        self.FUNC = []
def getVulnerabilityDetail(cveid, req):   
    errors = [] 
    vulnerabilityDetail = VulnerabilityDetail()
    try:
        cve = CVE.objects.get(cve_id=cveid)
        print(cve)
        vulnerabilityDetail.CVE = cve
        vulnerabilityDetail.CVSS = CVSS.objects.filter(cveid=cve)
        vulnerabilityDetail.EXPLOITS = EXPLOIT.objects.filter(cve=cve)
        vulnerabilityDetail.INFO = INFO.objects.filter(cve=cve)
        for info in vulnerabilityDetail.INFO:
            info.feature = DIFFFEATURE.objects.filter(info_id=info)
            reuses = REUSE.objects.filter(info_id=info)
            for reuse in reuses:
                reuse.feature = REUSEFEATURE.objects.filter(reuse=reuse)
                vulnerabilityDetail.REUSES.append(reuse)
        return vulnerabilityDetail
    except Exception as err:
        errors.append(err) 
        print(errors) 
        return None
                 
def display_meta(req):
    return render_to_response('add_vuln.html')
# Create your views here.

def index(req):
    return render_to_response('index.html' , {'user':req.user})

def vulnerabilityNVD(req):
    errors = []
    try:
        vulnerabilities = CVE.objects.all()
        for vuln in vulnerabilities:
            vuln.exploits = vuln.exploit_set.count()
        return render_to_response('vulnerabilityNVD.html', {\
                                                    'vulnerabilities':vulnerabilities, \
                                                    'user':req.user, \
                                                     })
    except Exception as err:
        errors.append(err)  
        return render_to_response('vulnerabilityNVD.html', {'errors': errors})
def vulnerabilityPatch(req):
    errors = []
    try:
    # vulnerabilities with patch
        vulnerabilitiesWithPatch = []
        infos = INFO.objects.exclude(diff_link='')
        for info in infos:
            if info.cve not in vulnerabilitiesWithPatch:
                vulnerabilitiesWithPatch.append(info.cve)
        sumPatch = len(vulnerabilitiesWithPatch)
        print(vulnerabilitiesWithPatch)
        pageInfo = pagination_vul(int(sumPatch), req)
        for vuln in vulnerabilitiesWithPatch:
            vuln.exploits = vuln.exploit_set.count()
        print(vulnerabilitiesWithPatch)
        return render_to_response('vulnerabilityWithPatch.html', {\
                                                    'vulnerabilities':vulnerabilitiesWithPatch, \
                                                    'user':req.user, \
                                                     'pageInfo':pageInfo})
    except Exception as err:
        errors.append(err)
        return render_to_response('vulnerabilityWithPatch.html', {'errors': errors})

def vulnerabilityReuse(req):    
    errors = []
    try:
        reuses = REUSE.objects.all()
        vulnerabilitiesWithReuse = []
        for reuse in reuses:
            if reuse.info_id.cve not in vulnerabilitiesWithReuse:
                vulnerabilitiesWithReuse.append(reuse.info_id.cve)
        sumReuse = len(vulnerabilitiesWithReuse)
        pageInfo = pagination_vul(int(sumReuse), req) 
        for vuln in vulnerabilitiesWithReuse:
            vuln.exploits = vuln.exploit_set.count()
        return render_to_response('vulnerabilityWithReuse.html', {\
                                                    'vulnerabilities':vulnerabilitiesWithReuse, \
                                                    'user':req.user, \
                                                     'pageInfo':pageInfo})
    except Exception as err:
        errors.append(err)  
        return render_to_response('vulnerabilityWithReuse.html', {'errors': errors})
    
def importBatch(req):
    return render_to_response('importBatch.html')

class UserForm(forms.Form):
    username = forms.CharField(max_length=20, label=u"username")
    password = forms.CharField(widget=forms.PasswordInput, max_length=20, label=u"password")
    
def login(req):
    
    if req.method == "POST":
        user_form = UserForm(req.POST)
        if user_form.is_valid():
            username = user_form.cleaned_data['username']
            password = user_form.cleaned_data['password']
            print ("valid")
            user = auth.authenticate(username=username, password=password)
            print("user")
            print(user)
            print(username + password)
            if user:
                print("password" + user.password)
                auth.login(req, user) 
                response = render_to_response("index.html", RequestContext(req))
                if 'next' in req.GET:
                        return HttpResponseRedirect(req.GET["next"])
                # 将username写入浏览器cookie,失效时间为3600
                return response
            else:
                return render_to_response("login.html", RequestContext(req, {'wrong':"wrong username or password"}))
        else:
            return render_to_response("login.html", RequestContext(req, {'wrong':"please input username and password"}))
    else:
        return render_to_response("login.html", RequestContext(req))
    

def logout(req):
    auth.logout(req)
    logout = "logout"
    return render_to_response("index.html", {'logout':logout}) 

class RegistrationForm(forms.Form):
    username = forms.CharField(label=u'username', max_length=100)
    password1 = forms.CharField(widget=forms.PasswordInput, max_length=20, label=u"password1")
    password2 = forms.CharField(widget=forms.PasswordInput, max_length=20, label=u"password2")
    email = forms.EmailField(label=u'email')
    
def registration(req):
    from django.contrib.auth.models import User
    if req.method == "POST":
        uf = RegistrationForm(req.POST)
        if uf.is_valid():
            # get form
            username = uf.cleaned_data['username']
            password1 = uf.cleaned_data['password1']
            password2 = uf.cleaned_data['password2']
            email = uf.cleaned_data['email']
            errors = []
            if password1 != password2:
                errors.append("Entered passwords differ!")
                return render_to_response('registration.html', RequestContext(req, {'uf':uf, 'errors':errors})) 
            
            filterResult = User.objects.filter(username=username)  #c************  
            if len(filterResult) > 0:  
                errors.append("A username already exists")  
                return render_to_response('registration.html', RequestContext(req, {'uf':uf, 'errors':errors})) 
            # install to mysql
            # user = User.objects.create(username,email,password2)
            user = User.objects.create_user(username, email, password2)
            user.save()
            # login
            # login_user=auth.authenticate(username=username, password=password1)
            # auth.login(req, login_user) 
            # 返回注册成功页面
            return render_to_response('success.html', RequestContext(req, {'tips':"Registration successful.Please login" + password2}))
        else:
            errors.append("Please input username、password and email")
            return render_to_response('registration.html', RequestContext(req, {'uf':uf, 'errors':errors}))    
    else:
        uf = RegistrationForm()
        return render_to_response('registration.html', context_instance=RequestContext(req, {'uf':uf}))

def forum(req):
    return render_to_response('forum.html', {'user':req.user})

def detailVul(req):
    errors = []
    try:
        if 'q' in req.GET:
            q = req.GET['q']
            if not validCVE(q):
                errors.append('Enter a search term.')
            else:
                if not re.match('^CVE-', q):
                    q = 'CVE-' + q
            vulnerabilityDetail = getVulnerabilityDetail(q, req)
            if vulnerabilityDetail == None:
                errors.append("No Term Found")
                return render_to_response('detail_vul.html', {'errors': errors, 'query':q})
            return render_to_response('detail_vul.html', {'query':q, 'vulnerabilityDetail':vulnerabilityDetail})
        return render_to_response('detail_vul.html', {'errors': errors})
    except Exception as err:
        errors.append(err)
        return render_to_response('detail_vul.html', {'errors': errors})
    

def validCVE(cveid):
    patt = '^(CVE-)?[0-9]{4}-[0-9]{1,39}$'
    m = re.match(patt, cveid)
    if not m:
        return False
    return True

def searchCVE(req):
    errors = []
    query = []
    q = req.GET['q']
    if not q:
        errors.append('Enter a search term.')
    elif not validCVE(q):
        errors.append('Incorrect CVE ID, expected format: CVE-[0-9]{4}-[0-9]{1,39} or [0-9]{4}-[0-9]{1,39}')
    else:            
        query.append(q)
        try:
            vulnerabilities = CVE.objects.filter(cve_id__contains=q)
            for vuln in vulnerabilities:
                vuln.exploits = vuln.exploit_set.count()
            return render_to_response('search_results.html', {'vulnerabilities':vulnerabilities, 'user':req.user, 'q':q})
        except:
            errors.append("ERROR")
    return render_to_response('search_results.html', {'errors': errors, 'q':q, 'user':req.user})      

def searchVul(req):
    if 'q' in req.GET:  # search 
        return searchCVE(req)
    elif 'ad_q' in req.GET:  # advanced search
        return searchAdvanced(req)
    # elif 'Analysis' in req.GET:  # analysis
    #    return analysis(req)
    else:
        return render_to_response('404.html') 

def searchAdvanced(req):
        errors = []
        query = []
        vulnerabilities = []
        cursor = connection.cursor()
        sql = "select * from vulnerability_cve"
        condition = None
        exploitsFlag = 0
        if 'ExploitsCheckBox' in req.GET:
            ExploitsCheck = req.GET['ExploitsCheckBox']
            if ExploitsCheck:
                exploitsFlag = 1
                
        reuseFlag = 0
        if 'ReuseCheckBox' in req.GET:
            ReuseCheck = req.GET['ReuseCheckBox']
            if ReuseCheck:
                reuseFlag = 1
                
        resuseFeatureFlag = 0
        resuseFeatureCves = []
        if 'ReuseFeatureList' in req.GET:
            ReuseFeature = req.GET['ReuseFeatureList']
            if ReuseFeature:
                resuseFeatureFlag = 1
                feature = FEATURE.objects.get(id=ReuseFeature)
                resuseFeatures = REUSEFEATURE.objects.filter(feature=feature)
                for reuseFeature in resuseFeatures:
                    if reuseFeature.reuse.info_id.cve not in resuseFeatureCves:
                        resuseFeatureCves.append(reuseFeature.reuse.info_id.cve)
        diffFlag = 0        
        if 'DiffCheckBox' in req.GET:
            DiffCheck = req.GET['DiffCheckBox']
            if DiffCheck:
                diffFlag = 1
        # CveIdentifier CveIdentifierTextBox
        CveIdentifier = req.GET['CveIdentifierTextBox']
        if CveIdentifier:
            if not validCVE(CveIdentifier):
                errors.append('Incorrect CVE ID, expected format: CVE-[0-9]{4}-[0-9]{1,39} or [0-9]{4}-[0-9]{1,39}')
            else:
                temp = "CVEID rlike '[CVE-]?" + CveIdentifier + "'" 
                condition = add_condition(condition, temp)
                query.append('CVEID:' + CveIdentifier)
        
        # Keyword QueryTextBox    
        keyword = req.GET['QueryTextBox']
        if keyword:
            if len(keyword) > 20:
                errors.append('Please submit keyword 20 characters or shorter')
            else:
                temp = "Description rlike '.*" + keyword + ".*'" 
                condition = add_condition(condition, temp)
                query.append('Description KeyWords:' + keyword)
                
        # cweid CweDropDownList    
        cweid = req.GET['CweDropDownList']
        if cweid != "":
            if (cweid == "CWE-noinfo") or (cweid == 'CWE-Other'):
                temp = "cweid is null"
            else:
                temp = "CWEID = '" + cweid + "'"
                query.append('CWEID:' + "Get the CWE Value from ID is not done .we have no cwe dictionary yet")
            condition = add_condition(condition, temp)
            
        # Vendor CPEVendorTextBox
        vendor = req.GET['CPEVendorTextBox']
        if vendor:
            if len(vendor) > 20:
                errors.append('Please submit Vendor 20 characters or shorter')
            else:  # if has cpe then use cpe sql
                sql = "select * from vulnerability_cve"
                temp = "company= '" + vendor + "'"
                condition = add_condition(condition, temp)
                query.append('Vendor:' + vendor)
        # Product CPEProductTextBox
        product = req.GET['CPEProductTextBox']
        if product:
            if len(product) > 20:
                errors.append('Please submit Product 20 characters or shorter')
            else:  # if has cpe then use cpe sql
                sql = "select * from vulnerability_cve"
                temp = "name rlike '.*" + product + ".*'"
                condition = add_condition(condition, temp)
                query.append('Product:' + product)
        # version CPEVersionTextBox
        version = req.GET['CPEVersionTextBox']
        if version:
            if not product:
                errors.append('Version needs Product first')
            elif len(version) > 20:
                errors.append('Please submit Version 20 characters or shorter')
            else:
                sql = "select * from vulnerability_cve"
                temp = "SoftwareVersion = '" + version + "'"
                condition = add_condition(condition, temp)
                query.append('Version:' + version)
        # Modify date Range
        # startTime ModDateStartMonthDropDown ModDateStartYearDropDown
        flag = None
        month = req.GET['ModDateStartMonthDropDown']
        year = req.GET['ModDateStartYearDropDown']
        if month != "0" and year != "0":
            startTime = year + "-" + month.zfill(2) + "-01T00:00.000-00:00"
            temp = "update_date >= '" + startTime + "'"
            condition = add_condition(condition, temp)
            query.append('Modified Date Start Time:' + year + "-" + month.zfill(2))
        elif (month == '0' and year != '0') or (month != '0' and year == '0'):
            flag = 1
        # endTime  ModDateEndMonthDropDown ModDateEndYearDropDown
        month = req.GET['ModDateEndMonthDropDown']
        year = req.GET['ModDateEndYearDropDown']
        if month != "0" and year != "0":
            endTime = year + "-" + month.zfill(2) + "-31T23:59.999-23:59"
            temp = "update_date <= '" + endTime + "'"
            condition = add_condition(condition, temp)
            query.append('Modified Date End Time:' + year + "-" + month.zfill(2))
        elif (month == '0' and year != '0') or (month != '0' and year == '0'):
            flag = 1 
        if flag != None:
            errors.append('Any dates chosen must select both Month and Year')
        # CVSS 
        # CvssSevBaseDropDown
        res = req.GET['CvssSevBaseDropDown']
        if res != "":
            if res == "LOW":
                low = 0
                high = 3
            elif res == "MEDIUM":
                low = 4
                high = 6
            elif res == "MEDIUM_HIGH":
                low = 4
                high = 10
            elif res == "HIGH":
                low = 7
                high = 10
            temp = "CVSS >= '%s' and CVSS <= '%s'" % (low, high)
            condition = add_condition(condition, temp)
            query.append('Severity (Base Score Range):' + str(res))
            # CvssAvDropDown
        
        res = req.GET['CvssAvDropDown']
        cvssAv = 0
        cvsss = []
        cvss_cves = []
        if res != "":
            cvssAv = 1
            if res == "LOCAL":
                cvsss = CVSS.objects.exclude(accessVector__icontains='network').filter(accessVector__icontains='Local')
            elif res == "LOCAL_NETWORK":
                cvsss = CVSS.objects.filter(accessVector__icontains='network').filter(accessVector__icontains='Local')
            elif res == "NETWORK":
                cvsss = CVSS.objects.exclude(accessVector__icontains='Local').filter(accessVector__icontains='network')
            for cvss in cvsss:
                if cvss.cveid not in cvss_cves:
                    cvss_cves.append(cvss.cveid)
        if errors:
            return render_to_response('search_advanced.html', {'errors': errors})
        if condition:
            sql = sql + " where " + condition + " order by CVEID DESC"
        try:
            sql += ";"
            print(sql)
            cursor.execute(sql)
            # get data
            desc = cursor.description
            rows = [ dict(zip([col[0] for col in desc], row)) for row in cursor.fetchall()]
            
            rows = rows
            print(rows)
            for row in rows:
                cveid = row['CVEID']
                vulnTemp = CVE.objects.get(cve_id=cveid)   
                vulnTemp.exploits = vulnTemp.exploit_set.count()
                if exploitsFlag > 0 and vulnTemp.exploits <= 0:
                    continue
                if reuseFlag > 0:
                    info = INFO.objects.filter(cve=vulnTemp)
                    if not info:
                        continue
                    reuse = REUSE.objects.filter(info_id=info[0])
                    if not reuse:
                        continue
                if diffFlag > 0:
                    info = INFO.objects.filter(cve=vulnTemp).exclude(diff_link='')
                    if not info:
                        continue
                if cvssAv > 0:
                    if vulnTemp not in cvss_cves:
                        continue
                if resuseFeatureFlag > 0:
                    if vulnTemp not in resuseFeatureCves:
                        continue
                vulnerabilities.append(vulnTemp)
            return render_to_response('search_results.html',
                {'vulnerabilities':vulnerabilities, 'q':query})
        except:
            errors.append('Execute sql error')
        finally:
            cursor.close()
        return render_to_response('searchAdvanced.html', {'errors': errors})
def search_advanced(req):
    # show query page 
    features = FEATURE.objects.all()
    return render_to_response('searchAdvanced.html', {'features':features})
def add_condition(condition, str1):
    if condition:
        str1 = " and " + str1 
        condition += str1
    else:
        condition = str1
    return condition

def add_Save(req):
    curtime = datetime.now()
    errors = []
    if req.method == 'GET':  
        print("GET")  
        cve_id = req.GET['cve_id']
        cwe_id = req.GET['cwe_id']
        vuln_type = req.GET['vuln_type']
        cvss_id = req.GET['cvss_id']
        description = req.GET['description']
        user = req.GET['user']
        cveResult = CVE.objects.filter(cve_id=cve_id)
        if len(cveResult) > 0:
            errors.append("cve exists")
            return render_to_response('add_success.html', {'errors':errors})
        cve = CVE()
        cve.cve_id = cve_id
        cve.cwe_id = cwe_id
        cve.vuln_type = vuln_type
        cve.cvss_id = cvss_id
        cve.description = description
        cve.user = user
        cve.update_date = curtime
        cve.save()
    return render_to_response('add_success.html', {'errors':errors})

def pagination_vul(sum1, req):
    try:
        errors = []
        # page index info
        pageInfo = PageIndex()
        pageInfo.sum = sum1
        pageInfo.endPageNum = sum1 / PAGENUMS + 1
        # query string  
        if 'QUERY_STRING' in req.META:
            queryString = req.META['QUERY_STRING']
            re.sub('&startIndex.*$', '', queryString)
            pageInfo.queryString = queryString
        startIndex = 0
        if 'startIndex' in req.GET:
            startIndex = int(req.GET['startIndex'])  ###########take care of req
        pageInfo.curIndex = startIndex + 1  # page index start from 1,so it needs +1 there  
        pageInfo.endIndex = pageInfo.getEndIndex()
        if sum1 > PAGENUMS:
            pageInfo.lastPageIndex = sum1 - sum1 % PAGENUMS
        else:
            pageInfo.lastPageIndex = 0
        # page num info
        firstPageNum = 1
        if 'firstPageNum' in req.GET:
            firstPageNum = int(req.GET['firstPageNum'])
        lastPageNum = firstPageNum + 9
        if lastPageNum > pageInfo.endPageNum:
            lastPageNum = pageInfo.endPageNum
        pageInfo.curPageNum = startIndex / PAGENUMS + 1
        pageInfo.pages = range(firstPageNum, lastPageNum + 1)
        if pageInfo.curPageNum == lastPageNum:  # and pageInfo.curPageNum != pageInfo.endPageNum:#the last pageNum adjust nav bar
            lastPageNum = pageInfo.curPageNum + 5 
            if lastPageNum > pageInfo.endPageNum:
                lastPageNum = pageInfo.endPageNum
            firstPageNum = lastPageNum - 9
            if firstPageNum < 1:
                firstPageNum = 1
        elif pageInfo.curPageNum == firstPageNum:  # and pageInfo.curPageNum != 1:
            firstPageNum = pageInfo.curPageNum - 5
            if firstPageNum < 1:
                firstPageNum = 1
            lastPageNum = firstPageNum + 9
        elif pageInfo.curPageNum == 1:
            firstPageNum = 1
            lastPageNum = 10
            if lastPageNum > pageInfo.endPageNum:
                lastPageNum = pageInfo.endPageNum
        elif pageInfo.curPageNum == pageInfo.endPageNum:
            lastPageNum = pageInfo.endPageNum
            firstPageNum = pageInfo.curPageNum - 9
            if firstPageNum < 1:
                firstPageNum = 1
        pageInfo.page = firstPageNum
        pageInfo.pages = range(firstPageNum, lastPageNum + 1)
        pageInfo.firstPageNum = firstPageNum
        print(pageInfo.curIndex)
        print(pageInfo.endIndex)
        return pageInfo        
    except Exception as e:
        errors.append(e)
        return render_to_response('search_results.html', {'errors': errors})
        
def addVulnerability(req):
    if '_save' in req.GET: 
        return add_Save(req)
    else:
        return render_to_response('add_vuln.html')
     
def editVulnerability(req):
    if 'q' in req.GET:
        q = req.GET['q']
        vulnerability = CVE.objects.get(cve_id=q)
        return render_to_response('edit_vuln.html', {'vulnerability':vulnerability})
    elif '_update' in req.GET:
        cve_id = req.GET['cve_id']
        vulnerability = CVE.objects.get(cve_id=cve_id)
        vulnerability.cve_id = req.GET['cve_id']
        vulnerability.cwe_id = req.GET['cwe_id']
        vulnerability.vuln_type = req.GET['vuln_type']
        vulnerability.cvss_id = req.GET['cvss_id']
        vulnerability.description = req.GET['description']
        vulnerability.user = req.GET['user']
        vulnerability.save()
        return render_to_response("success.html")
    else:
        return render_to_response('edit_vuln.html')
class DiffFeature():
    def __init__(self):
        self.num = None
        self.feature = []
def diffInfoShow(req):
    errors = []
    difftxt = None
    diffInfo = None
    try:
        if 'info' in req.GET:
            info = req.GET['info']
        diffInfo = INFO.objects.get(id=int(info))
        diffInfoList = []
        if diffInfo.diff_link:
            diffInfoList = INFO.objects.filter(diff_link=diffInfo.diff_link)
        with open(diffInfo.diff_file) as f:
            difftxt = f.read()
        # handle features
        diffFeatures = getDiffFeatures(diffInfo)
        return render_to_response('diffInfo.html', {'errors': errors, 'info':diffInfo, 'difftxt':difftxt, 'diffList':diffInfoList, 'diffFeatures':diffFeatures})
    except Exception as err:
        errors.append(err)
        return render_to_response('diffInfo.html', {'errors': errors})
    
def getDiffFeatures(info):
    str_sql = "select distinct number from vulnerability_difffeature where info_id_id=" + str(info.id)
    print(str_sql)
    rows = my_custom_sql(str_sql)
    print(rows)
    diffFeatures = []
    for row in rows:
        diffFeature = DiffFeature()
        diffFeature.num = row['number']
        print(diffFeature.num)
        diffFeature.feature = DIFFFEATURE.objects.filter(info_id=info, number=diffFeature.num)
        print(diffFeature.feature)
        diffFeatures.append(diffFeature)
    return diffFeatures

def my_custom_sql(str_sql):
    cursor = connection.cursor()
    cursor.execute(str_sql)
    desc = cursor.description
    rows = [ dict(zip([col[0] for col in desc], row)) for row in cursor.fetchall()]
    return rows
def download(req):
    from django.http import StreamingHttpResponse
    errors = []
    try:
        def file_iterator(file_name, chunk_size=512):
            with open(file_name) as f:
                while True:
                    c = f.read(chunk_size)
                    if c:
                        yield c
                    else:
                        break
        if 'file' in req.GET:
            filename = req.GET['file']
            m = filename.split('\\')
            response = StreamingHttpResponse(file_iterator(filename))
            response['Content-Type'] = 'application/octet-stream'
            str1 = 'attachment;filename="diff_' + m[-1] + '"'
            response['Content-Disposition'] = str1.format(filename)
            return response
        
        if 'info'in req.GET:
            infoid = req.GET['info']
            func = req.GET['func']
            version = req.GET['version']
            info = INFO.objects.get(id=infoid)
            reuse = REUSE.objects.get(info_id=info, version=version, patch_func=func)
            response = StreamingHttpResponse(reuse.code)
            response['Content-Type'] = 'application/octet-stream'
            str1 = 'attachment;filename="' + info.cve.cve_id + '_' + reuse.patch_func + '.txt"'
            response['Content-Disposition'] = str1.format()
            return response
    except Exception as err:
        errors.append(err)
        return HttpResponse("Download failed!")  
def featureShow(req):
    errors = []
    try:
        features = FEATURE.objects.all()
        return render_to_response('aboutFeature.html', {'features':features})
    except Exception as err:
        errors.append(err)
        return render_to_response('aboutFeature.html', {'errors':errors})
def rewardIndex(req):
    return render_to_response('rewardIndex.html', {'user':req.user})
def rewardIncompleteListDiff(req):
    from django.db.models import Q
    errors = []
    try:
        infos = []
        infosTemp = INFO.objects.filter(Q(diff_link='') | Q(diff_file=''))
        for info in infosTemp:
            reward = REWARDDIFF.objects.filter(info_id=info)
            if reward:
                continue
            infos.append(info)
        return render_to_response('rewardIncompleteListDiff.html', {'user':req.user, 'errors':errors, 'infos':infos})
    except Exception as err:
        errors.append(err)    
        return render_to_response('rewardIncompleteListDiff.html', {'user':req.user, 'errors':errors})
def rewardDiffAddToList(req):
    errors = []
    try:
        if '_toReward' in req.GET: 
            print(req.GET)
            infoId = req.GET['infoId']
            title = req.GET['title']
            credit = req.GET['CreditList']
            date = datetime.now()
            rewardDiff = REWARDDIFF()
            info = INFO.objects.get(id=infoId)
            rewardDiff.info_id = info
            rewardDiff.title = title
            rewardDiff.publish_date = date
            rewardDiff.credits = CREDIT.objects.get(creditRank=credit)
            rewardDiff.save()
            errors.append("succeed")
            return render_to_response('rewardIncompleteListDiff.html', {'user':req.user})
        else:
            if 'infoId' in req.GET:
                infoId = req.GET['infoId']
                info = INFO.objects.get(id=infoId)
            creditlist = CREDIT.objects.all()
            if len(info.diff_file) > 0:
                with open(info.diff_file) as f:
                    difftxt = f.read()
                info.diff_file = difftxt
            return render_to_response('rewardDiffAddToList.html', {'errors':errors, 'user':req.user, 'info':info, 'credits':creditlist})
    except Exception as err:
        errors.append(err) 
        return render_to_response('rewardDiffAddToList.html', {'errors':errors, 'user':req.user})
class RewardDiff():
    def __init__(self):
        self.rewarddiff = REWARDDIFF
        self.submit = None
        
def rewardDiffList(req):
    errors = []
    try:
        rewardDiffs = []
        rewarddiffs = REWARDDIFF.objects.all()
        for reward in rewarddiffs:
            rewarddiff = RewardDiff()
            rewarddiff.rewarddiff = reward
            rewarddiff.submit = DIFFSUBMIT.objects.filter(rewardDiff=reward).count()
            if rewarddiff.rewarddiff.info_id.check_flag==True:
                continue
            rewardDiffs.append(rewarddiff)
        return render_to_response('rewardDiff.html', {'user':req.user, 'errors':errors, 'rewarddiffs':rewardDiffs})
    except Exception as err:
        errors.append(err)     
        return render_to_response('rewardDiff.html', {'user':req.user, 'errors':errors})
    
def handle_uploaded_file(f, filename, username): 
    f_path = filename 
    print(f_path)
    if not os.path.exists(f_path):
        os.makedirs(f_path)
    f_path = f_path + datetime.now().strftime('%Y%m%d%H%M%S') + username + '.txt'
    print(f_path)
    with open(f_path, 'wb+') as info: 
        for chunk in f.chunks(): 
            info.write(chunk) 
    return f_path
    
def rewardDiffAdd(req):
    errors = []
    try:
        if req.method == 'POST':
            diffLink = req.POST['diffLink']
            
            title = req.GET['rewardDiff']
            rewarddiff = REWARDDIFF.objects.get(title=title)
            
            f = req.FILES['difffile']
            filePath = handle_uploaded_file(f, DIFFFILENAME, req.user.username)
            
            diffSubmit = DIFFSUBMIT()
            diffSubmit.diff_link = diffLink
            diffSubmit.diff_file = filePath
            diffSubmit.user = req.user.username
            diffSubmit.rewardDiff = rewarddiff
            diffSubmit.submit_date = datetime.now()
            diffSubmit.save()
            return HttpResponse("Add diff succssfully!")
        else:
            if 'rewardDiff' in req.GET:
                title = req.GET['rewardDiff']
                rewarddiff = REWARDDIFF.objects.get(title=title)
                return render_to_response('rewardDiffAdd.html', RequestContext(req, {'user':req.user, 'errors':errors, 'rewarddiff':rewarddiff})) 
        return render_to_response('rewardDiffAdd.html', RequestContext(req, {'user':req.user, 'errors':errors}))
    except Exception as err:
        errors.append(err)     
        return render_to_response('rewardDiffAdd.html', {'user':req.user, 'errors':errors})    
def rewardIncompleteListExploits(req):
    errors = []
    vulnList=[]
    try:
        if req.method == 'POST':
            print(req.POST)
            var=req.POST[0]
            if '_toreward' in req.POST:
                rewardExploit=REWARDEXPLOIT()
        else:
            vulnerabilities = CVE.objects.all()
            for vuln in vulnerabilities:
                vuln.exploits = vuln.exploit_set.count()
                if vuln.exploits>0:
                    continue
                vulnList.append(vuln)
            print(vulnerabilities)
            return render_to_response('rewardIncompleteListExploits.html', RequestContext(req, {'errors':errors,'vulnerabilities':vulnList}))
    except Exception as err:
        errors.append(err) 
        return render_to_response('rewardIncompleteListExploits.html', RequestContext(req, {'errors':errors}))
def rewardExploitsList(req):
    
    return render_to_response('rewardIncompleteListExploits.html')
def rewardCheckList(req):
    return render_to_response('rewardIncompleteListCheck.html')
def rewardDiffCheckList(req):
    errors = []
    try:
        diffSubmits = DIFFSUBMIT.objects.filter(checkFlag=False)
        return render_to_response('rewardDiffCheckList.html', {'errors':errors, 'user':req.user, 'diffSubmits':diffSubmits})
    except Exception as err:
        errors.append(err)     
        return render_to_response('rewardDiffCheckList.html', {'errors':errors, 'user':req.user})
def rewardExploitCheckList(req):
    return render_to_response('rewardExploitCheckList.html')
def rewardInfoCheckList(req):
    return render_to_response('rewardInfoCheckList.html')
def diffCheck(req):
    errors = []
    difftxt = None
    try:
        if req.method == 'POST':
            diffsubmitId = req.GET['diffSubmitId']
            diffsubmit = DIFFSUBMIT.objects.get(id=diffsubmitId)
            if '_pass' in req.POST:
                diffsubmit.passFlag = True
                diffsubmit.checkFlag = True
                diffsubmit.save()
                info = diffsubmit.rewardDiff.info_id
                info.diff_link = diffsubmit.diff_link
                info.diff_file = diffsubmit.diff_file
                info.check_flag = True
                info.save()
            if '_ignore' in req.POST:
                diffsubmit.passFlag = False
                diffsubmit.checkFlag = True
                diffsubmit.save()
            diffSubmits = DIFFSUBMIT.objects.filter(checkFlag=False)
            return render_to_response('rewardDiffCheckList.html', RequestContext(req, {'errors':errors, 'user':req.user, 'diffSubmits':diffSubmits}))
        elif 'diffSubmitId' in req.GET:
            diffsubmitId = req.GET['diffSubmitId']
            diffsubmit = DIFFSUBMIT.objects.get(id=diffsubmitId)
            with open(diffsubmit.diff_file) as f:
                difftxt = f.read()
            return render_to_response('rewardDiffCheckDetail.html', RequestContext(req, {'diffsubmit':diffsubmit, 'user':req.user, 'difftxt':difftxt}))
    except Exception as err:
        errors.append(err)      
        return render_to_response('rewardDiffCheckDetail.html', RequestContext(req, {'errors':errors, 'user':req.user}))
